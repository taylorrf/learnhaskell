Então, o que é Haskell?
=======================

Haskell é uma <strong>linguagem de programação puramente funcional</strong>. Em linguagens de programação imperativas, você pensa nas coisas seguindo uma sequência computacional de tarefas sendo executadas, embora durante o processo possam mudar de estado. Por exemplo, ao definir uma variável com o valor 5, após isso faz alguma coisa, e em seguida define esta variável como sendo alguma outra coisa qualquer. Você possui o controle do fluxo da estrutura podendo fazer uma determinada ação diversas vezes. Na programação puramente funcional você não diz para o computador o que fazer, porém muitas vezes você diz em qual coisa está. O fatorial de um número é o produto de todos os números sobre 1 deste número; a soma de uma lista de números é o primeiro mais a soma de todos os outros números; e assim por diante. Você expressa isto na forma de funções. Você também não pode definir uma variável como sendo de um tipo e em seguida defini-lá como sendo alguma outra. Se você disser a uma função que algo é 5, você não poderá dizer depois que é outra coisa, porque você já disse que era 5. O que você é? Algum tipo de mentiroso? Então, em linguagens puramente funcionais, uma função não tem efeitos colaterais. A única coisa que podemos fazer com uma função é calcular algo e devolvê-lo como um resultado. Inicialmente, vi isto como uma limitação, porém isto realmente tem algumas consequências interessantes: se a função é chamada duas vezes com os mesmos parâmetros, isto garantirá o retorno de um mesmo resultado. Isso se chama <strong>transparência referencial</strong> e não só permite que o compilador raciocine sobre o comportamento do programa, como também permite que você deduza facilmente (e até mesmo prove) que uma função está correta e, em seguida, construa funções mais complexas juntando diversas funções simples por "colagem".


Haskell é <strong>preguiçoso</strong>. Isso significa que a menos que seja especificamente dito de outra forma, o Haskell não irá executar as funções e calcular as coisas antes que ele seja realmente obrigado a lhe mostrar um resultado. Isto vai bem de encontro com a transparência referencial, pois lhe permite pensar em programas como uma série de <strong>transformações nos dados</strong>. Isto também permite simplificar coisas como estruturas de dados infinitas. Digamos que você tem uma lista de números imutáveis [code] xs = [1,2,3,4,5,6,7,8] [/ code] e uma função [code] dobro [/ code] que multiplica cada elemento por 2 e em seguida retorna uma nova lista. Caso quiséssemos multiplicar nossa lista por 8, em uma linguagem imperativa fazendo [code] dobro (dobro (dobro (xs))) [/ code], ele provavelmente passaria uma vez pela lista, fazendo uma cópia e retornando. Em seguida, ele passaria por mais duas vezes e retornaria o resultado. Em uma linguagem preguiçosa, chamando [code] dobro [/ code] numa lista sem forçar que seja mostrado algum resultado assim que acabar, ela irá lhe dizer "Sim sim, faço isso mais tarde". Mas uma vez que você queira ver o resultado, o primeiro [code] dobro [/ code] dirá para o segundo que quer o resultado do 1, agora! O segundo 1 dirá para o terceiro 1 e o terceiro 1 relutantemente retornará o 1 duplicado, com um 2. O segundo 1 recebido retornará um 4 para o primeiro. O primeiro 1 olhará aquilo e dirá para você que o primeiro elemento é 8. Por isso, ele só passa uma vez pela lista e só quando realmente for necessário. Dessa maneira, quando você quiser alguma coisa de uma linguagem "preguiçosa", você poderá ter apenas alguns dados iniciais e eficientemente transformá-los e melhorá-los para que se assemelhem com aquilo que você quer no final.

Haskell é <strong>estaticamente tipado</strong>. Quando você compilar seu programa, o compilador saberá quais partes do código é um número, o que é uma string e assim por diante. Isso significa que uma série de possíveis erros poderão ser identificados em tempo de compilação. Se você tentar adicionar um número a uma string, o compilador irá reclamar. Haskell usa um bom sistema de tipos que tem inferência de tipo. Isso significa que você não precisa explicitamente identificar cada pedaço de código com um tipo, porque o sistema de tipos inteligente descobrirá muito sobre ele. Se disser que [code] a = 5 + 4 [/ code], você não precisará dizer para o Haskell que [código] a [/ code] é um número, ele descobrirá isso por si só. Inferência de tipo também permite que o seu código seja mais genérico. Se fizer uma função de soma com dois parâmetros e não declarar explicitamente seus tipos, ela funcionará com quaisquer valores que sejam números.

Haskell é <strong>elegante e conciso</strong>. Isto porque utiliza uma série de conceitos de alto nível, programas Haskell são normalmente mais curtos do que os seus equivalentes imperativos. E programas mais curtos são mais fáceis de se manter e têm menos bugs.

Haskell foi feito por <strong>caras realmente inteligentes</strong> (com doutorado). O trabalho sobre Haskell começou em 1987 quando uma comissão de pesquisadores se reuniu para projetar uma linguagem matadora. Em 2003, o Relatório Haskell foi publicado já com uma versão estável da linguagem.
