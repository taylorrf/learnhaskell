Então, o que é Haskell?
=======================

Haskell é uma linguagem de programação puramente funcional.
Em linguagens de programação imperativas você pensa nas coisas seguindo uma sequência computacional de tarefas sendo executadas, embora durante o processo possam mudar de estado. Por exemplo, você define uma variável como 5 e então faz alguma coisa e em seguida a define como sendo alguma outra coisa qualquer. Você possui o controle do fluxo da estrutura podendo fazer uma determinada ação diversas vezes. Na programação puramente funcional você não diz para o computador o que fazer, porém muitas vezes você diz em qual coisa está. O fatorial de um número é o produto de todos os números sobre 1 deste número, a soma de uma lista de números é o primeiro mais a soma de todos os outros números e assim por diante. Você expressa isto na forma de funções. Você também não pode definir uma variável como sendo alguma coisa e em seguida defini-lá como sendo alguma outra coisa mais tarde. Se você disser a uma função que algo é 5, você não poderá dizer depois que é alguma outra coisa porque você já disse que era 5. O que você é? Algum tipo de mentiroso? Então, em linguagens puramente funcionais, uma função não tem efeitos colaterais. A única coisa que podemos fazer com uma função é calcular algo e devolvê-lo como um resultado. Inicialmente, eu vi isto como uma limitação, porém isto realmente tem algumas consequências interessantes: se a função é chamada duas vezes com os mesmos parâmetros, isto garantirá o retorno de um mesmo resultado. Isso se chama <strong>transparência referencial</strong> e não só permite que o compilador raciocine sobre o comportamento do programa, como também permite que você deduza facilmente (e até mesmo prove) que uma função está correta e, em seguida, construa funções mais complexas juntando diversas funções simples por "colagem".


Haskell é preguiçoso. Isso significa que a menos que seja especificamente dito de outra forma, Haskell não irá executar funções e calcular as coisas antes que ele seja realmente obrigado a lhe mostrar um resultado. Isto vai bem de encontro com a transparência referencial que lhe permite pensar em programas como uma série de transformações nos dados. Isto também permite simplificar coisas como estruturas de dados infinitas. Digamos que você tem uma lista de números imutáveis [code] xs = [1,2,3,4,5,6,7,8] [/ code] e uma função [code] doubleMe [/ code] que multiplica cada elemento por 2 e em seguida retorna uma nova lista. Caso quiséssemos multiplicar nossa lista por 8 em uma linguagem imperativa fazendo [code] doubleMe (doubleMe (doubleMe (xs ))) [/ code], ele provavelmente iria passar uma vez pela lista, fazer uma cópia e retornar. Em seguida, ele iria passar por mais duas vezes e retornar o resultado. Em uma linguagem preguiçosa, chamando [code] doubleMe [/ code] numa lista sem forçar para que seja mostrado algum resultado assim que acabar, ela irá lhe dizer "Sim sim, faço isso mais tarde". Mas uma vez que você queira ver o resultado, o primeiro [code] doubleMe [/ code] dirá para o segundo que quer o resultado do 1, agora! O segundo 1 irá dizer para o terceiro 1 e o terceiro 1 relutantemente irá retornar o 1 duplicado, com um 2. O segundo 1 recebido irá retornar um 4 para o primeiro. O primeiro 1 olhará aquilo e dirá para você que o primeiro elemento é 8. Por isso, ele só passa uma vez pela lista e só quando você realmente precisa dela. Dessa maneira, quando você quiser alguma coisa em uma linguagem "preguiçosa", você poderá ter apenas alguns dados iniciais e eficientemente transformá-los e melhorá-los para que eles se assemelhem com aquilo que você quer no final.

Haskell é estaticamente tipado. Quando você compilar seu programa, o compilador saberá quais partes do código são números, quais são string, e assim por diante. Isso significa que uma série de possíveis erros poderão ser identificados no momento da compilação. Se você tentar adicionar um número a uma string, o compilador irá se queixar. Haskell usa um bom sistema de tipos que se utiliza de inferência de tipo. Ou seja, você não precisa explicitamente identificar cada pedaço de código com um tipo porque o sistema de tipos inteligente é capaz de inferir. Se você disser `a = 5 + 4`, você não precisará dizer para o Haskell que `a` é um número, o compilador irá inferir essa informação. Inferência de tipo também permite que o seu código seja mais genérico. Se você descrever uma função de soma com dois parâmetros e não declarar explicitamente seus tipos, ela funcionará com quaisquer valores que sejam números.

Haskell é <em> elegante e conciso </ em>. Isto porque ele utiliza uma série de conceitos de alto nível, programas Haskell são normalmente mais curtos do que os seus equivalentes imperativos. E programas mais curtos são mais fáceis de se manter e têm menos bugs.

Haskell foi feito por caras realmente inteligentes (com doutorado). O trabalho sobre Haskell começou em 1987 quando uma comissão de pesquisadores se reuniu para projetar uma linguagem matadora. Em 2003, o Relatório Haskell foi publicado já com uma versão estável da linguagem.
