title: Bytestrings

text: Lists are a cool and useful data structure. So far, we've used them pretty much everywhere. There are a multitude of functions that operate on them and Haskell's laziness allows us to exchange the for and while loops of other languages for filtering and mapping over lists, because evaluation will only happen once it really needs to, so things like infinite lists (and even infinite lists of infinite lists!) are no problem for us. That's why lists can also be used to represent streams, either when reading from the standard input or when reading from files. We can just open a file and read it as a string, even though it will only be accessed when the need arises.

However, processing files as strings has one drawback: it tends to be slow. As you know, [code]String[/code] is a type synonym for [code][Char][/code]. [code]Char[/code]s don't have a fixed size, because it takes several bytes to represent a character from, say, Unicode. Furthemore, lists are really lazy. If you have a list like [code][1,2,3,4][/code], it will be evaluated only when completely necessary. So the whole list is sort of a promise of a list. Remember that [code][1,2,3,4][/code] is syntactic sugar for [code]1:2:3:4:[][/code]. When the first element of the list is forcibly evaluated (say by printing it), the rest of the list [code]2:3:4:[][/code] is still just a promise of a list, and so on. So you can think of lists as promises that the next element will be delivered once it really has to and along with it, the promise of the element after it. It doesn't take a big mental leap to conclude that processing a simple list of numbers as a series of promises might not be the most efficient thing in the world.

That overhead doesn't bother us so much most of the time, but it turns out to be a liability when reading big files and manipulating them. That's why Haskell has <em>bytestrings</em>. Bytestrings are sort of like lists, only each element is one byte (or 8 bits) in size. The way they handle laziness is also different. 
Bytestrings come in two flavors: strict and lazy ones. Strict bytestrings reside in [code]Data.ByteString[/code] and they do away with the laziness completely. There are no promises involved; a strict bytestring represents a series of bytes in an array. You can't have things like infinite strict bytestrings. If you evaluate the first byte of a strict bytestring, you have to evaluate it whole. The upside is that there's less overhead because there are no thunks (the technical term for <i>promise</i>) involved. The downside is that they're likely to fill your memory up faster because they're read into memory at once.
The other variety of bytestrings resides in [code]Data.ByteString.Lazy[/code]. They're lazy, but not quite as lazy as lists. Like we said before, there are as many thunks in a list as there are elements. That's what makes them kind of slow for some purposes. Lazy bytestrings take a different approach â€” they are stored in chunks (not to be confused with thunks!), each chunk has a size of 64K. So if you evaluate a byte in a lazy bytestring (by printing it or something), the first 64K will be evaluated. After that, it's just a promise for the rest of the chunks. Lazy bytestrings are kind of like lists of strict bytestrings with a size of 64K. When you process a file with lazy bytestrings, it will be read chunk by chunk. This is cool because it won't cause the memory usage to skyrocket and the 64K probably fits neatly into your CPU's L2 cache.
If you look through the <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString-Lazy.html" target="_blank">documentation</a> for [code]Data.ByteString.Lazy[/code], you'll see that it has a lot of functions that have the same names as the ones from [code]Data.List[/code], only the type signatures have [code]ByteString[/code] instead of [code][a][/code] and [code]Word8[/code] instead of [code]a[/code] in them. The functions with the same names mostly act the same as the ones that work on lists. Because the names are the same, we're going to do a qualified import in a script and then load that script into GHCI to play with bytestrings. 


[code]B[/code] has lazy bytestring types and functions, whereas [code]S[/code] has strict ones. We'll mostly be using the lazy version.
The function <span class="function label">pack[/code] has the type signature [code]pack :: [Word8] -&gt; ByteString[/code]. What that means is that it takes a list of bytes of type [code]Word8[/code] and returns a [code]ByteString[/code]. You can think of it as taking a list, which is lazy, and making it less lazy, so that it's lazy only at 64K intervals.

What's the deal with that [code]Word8[/code] type? Well, it's like [code]Int[/code], only that it has a much smaller range, namely 0-255. It represents an 8-bit number. And just like [code]Int[/code], it's in the [code]Num[/code] typeclass. For instance, we know that the value [code]5[/code] is polymorphic in that it can act like any numeral type. Well, it can also take the type of [code]Word8[/code].

As you can see, you usually don't have to worry about the [code]Word8[/code] too much, because the type system can makes the numbers choose that type. If you try to use a big number, like [code]336[/code] as a [code]Word8[/code], it will just wrap around to [code]80[/code].
We packed only a handful of values into a [code]ByteString[/code], so they fit inside one chunk. The [code]Empty[/code] is like the [code][][/code] for lists.

[function]unpack[/code] is the inverse function of [code]pack[/code]. It takes a bytestring and turns it into a list of bytes. 
[function]fromChunks[/code] takes a list of strict bytestrings and converts it to a lazy bytestring. [function]toChunks[/code] takes a lazy bytestring and converts it to a list of strict ones.


This is good if you have a lot of small strict bytestrings and you want to process them efficiently without joining them into one big strict bytestring in memory first.
The bytestring version of [code]:[/code] is called [function]cons[/code] It takes a byte and a bytestring and puts the byte at the beginning. It's lazy though, so it will make a new chunk even if the first chunk in the bytestring isn't full. That's why it's better to use the strict version of [code]cons[/code], [function]cons'[/code] if you're going to be inserting a lot of bytes at the beginning of a bytestring.

As you can see [function]empty[/code] makes an empty bytestring. See the difference between [code]cons[/code] and [code]cons'[/code]? With the [code]foldr[/code], we started with an empty bytestring and then went over the list of numbers from the right, adding each number to the beginning of the bytestring. When we used [code]cons[/code], we ended up with one chunk for every byte, which kind of defeats the purpose.
Otherwise, the bytestring modules have a load of functions that are analogous to those in [code]Data.List[/code], including, but not limited to, [code]head[/code], [code]tail[/code], [code]init[/code], [code]null[/code], [code]length[/code], [code]map[/code], [code]reverse[/code], [code]foldl[/code], [code]foldr[/code], [code]concat[/code], [code]takeWhile[/code], [code]filter[/code], etc. 

It also has functions that have the same name and behave the same as some functions found in [code]System.IO[/code], only [code]String[/code]s are replaced with [code]ByteString[/code]s. For instance, the [code]readFile[/code] function in [code]System.IO[/code] has a type of [code]readFile :: FilePath -&gt; IO String[/code], while the [function]readFile[/code] from the bytestring modules has a type of [code]readFile :: FilePath -&gt; IO ByteString[/code]. Watch out, if you're using strict bytestrings and you attempt to read a file, it will read it into memory at once! With lazy bytestrings, it will read it into neat chunks.

Let's make a simple program that takes two filenames as command-line arguments and copies the first file into the second file. Note that [code]System.Directory[/code] already has a function called [code]copyFile[/code], but we're going to implement our own file copying function and program anyway.


We make our own function that takes two [code]FilePath[/code]s (remember, [code]FilePath[/code] is just a synonym for [code]String[/code]) and returns an I/O action that will copy one file into another using bytestring. In the [code]main[/code] function, we just get the arguments and call our function with them to get the I/O action, which is then performed.

Notice that a program that doesn't use bytestrings could look just like this, the only difference is that we used [code]B.readFile[/code] and [code]B.writeFile[/code] instead of [code]readFile[/code] and [code]writeFile[/code]. Many times, you can convert a program that uses normal strings to a program that uses bytestrings by just doing the necessary imports and then putting the qualified module names in front of some functions. Sometimes, you have to convert functions that you wrote to work on strings so that they work on bytestrings, but that's not hard.
Whenever you need better performance in a program that reads a lot of data into strings, give bytestrings a try, chances are you'll get some good performance boosts with very little effort on your part. I usually write programs by using normal strings and then convert them to use bytestrings if the performance is not satisfactory.