title: Obtendo nossos pés molhados com Maybe

text: Agora que nós temos uma vaga ideia sobre o que são monads, vamos ver se podemos fazer essa ideia um pouco menos vaga.

Para a surpresa, [code]Maybe[/code] é um monad, então vamos explora-lo um pouco mais e ver se podemos combina-lo com o que nós aprendemos sobre monads.

Você deve certificar-se que entendeu <a href="functors-applicative-functors-and-monoids#applicative-functors">applicatives</a> nesse ponto. Isso é bom se você tem uma noção como as várias instâncias de [code]Applicative[/code] trabalham e que tipo de cálculo eles representam, porque monads não são nada mais do que tornar o nosso conhecimento atualizado e aplicável.

Um valor do tipo [code]Maybe a[/code] representa um valor do tipo [code]a[/code] com o contexto e uma possível de falha anexada. Um valor de [code]Just "dharma"[/code] significa que a string [code]"dharma"[/code] existe enquanto que o valor de [code]Nothing[/code] representa sua ausência, ou se você olhar para a string como um resultado de um cálculo, isso significa que o cálculo falhou.

Quando nós olhamos para [code]Maybe[/code] com uma functor, vimos que se queremos em [code]fmap[/code] uma função sobre ela, ela é mapeada internamente se o valor é [code]Just[/code], caso contrário o [code]Nothing[/code] é mantido porque não há nada para mapear.

Assim:

Como um applicative functor, que funciona de forma semelhante. Contudo, applicatives também tem uma função wrapped. [code]Maybe[/code] é um applicative functor de tal forma que, quando usamos [code]&lt;*&gt;[/code] para aplicar uma função dentro de um [code]Maybe[/code] para um valor que está dentro de um [code]Maybe[/code], ambos tem que ser [code]Just[/code] para o resultado ser um valor [code]Just[/code], caso contrário resultado é [code]Nothing[/code]. Faz sentido porque se você está perdido ou a função que está aplicando, você não pode fazer nada fora, dessa forma você tem que propagar uma falha:

Quando usamos o estilo applicative para ter funções normais para agir em valores [code]Maybe[/code] isto é semelhante. Todos os valores têm que ser [code]Just[/code], caso contrário todos são [code]Nothing[/code]!

E agora vamos pensar como nos faríamos [code]&gt;&gt;=[/code] para [code]Maybe[/code]. Como nós falamos [code]&gt;&gt;=[/code] tem um valor monadic, e uma função que tem um valor normal e retorna um valor monadic e consegue aplicar essa função para um valor manadic. Como ele faz isso, se a função tem um valor normal? Bem, para fazer isso, ele tem que levar em conta o contexto desse valor manadic.

Neste caso, [code]&gt;&gt;=[/code] levaria um valor [code]Maybe a[/code] e uma função do tipo [code]a -&gt; Maybe b[/code] e de alguma maneira aplica a função para o [code]Maybe a[/code]. Para descobrir como ele faz isso, podemos usar a intuição que temos de code]Maybe[/code] ser um applicative functor. Vamos dizer que temos uma função [code]\x -&gt; Just (x+1)[/code]. Ela tem um número, acrescenta [code]1[/code] a ele e faz uma wraps para um [code]Just[/code]:

Se alimentamos ela em [code]1[/code], ela é calculada como [code]Just 2[/code]. Se nos damos a este número [code]100[/code], o resultado é [code]Just 101[/code]. Muito simples. Agora aqui está o chute: Como nós alimentamos um valor [code]Maybe[/code] para esta função? Se nos pensarmos como [code]Maybe[/code] age como um applicative functor, a resposta disso é muito fácil. Se nos alimentarmos um valor [code]Just[/code] pegamos o que está dentro de [code]Just[/code] e aplicamos a função pra ele. Se dado um [code]Nothing[/code], hmm, bem, então estamos com uma função [code]Nothing[/code] para aplica-lo. Neste caso vamos apenas fazer o que nós fizemos antes de dizer que o resultado é [code]Nothing[/code].

Em vez de chamar isso [code]&gt;&gt;=[/code], vamos char isso [code]applyMaybe[/code] por enquanto. É preciso um [code]Maybe a[/code] e uma função que retorna um [code]Maybe b[/code] e consegue aplicar esta função em um [code]Maybe a[/code]. Aqui está o código:

Ok, agora vamos jogar com ele um pouco. Nós vamos usar ele com uma função infixa assim o valor [code]Maybe[/code] está do lado esquerdo e a função do lado direto:

No exemplo acima, nos vimos que quando usamos [code]applyMaybe[/code] com um valor [code]Just[/code] e uma função, a função simplesmente foi aplicada no valor dentro de [code]Just[/code]. Quando nós tentamos usar isso com um [code]Nothing[/code], o resultado completo foi [code]Nothing[/code] Que tal se a função retornar um [code]Nothing[/code]?
Vamos ver:

Exatamente o que nós esperamos. Se o valor monadic à esquerda é um [code]Nothing[/code], a coisa toda é [code]Nothing[/code]. E se a função a direita retorna um [code]Nothing[/code], o resultado novamente é [code]Nothing[/code]. Isto é muito similar quando nós usamos [code]Maybe[/code] como um applicative e nós obtemos um resultado [code]Nothing[/code] se em alguma parte havia um [code]Nothing[/code].

Parece que para [code]Maybe[/code], nós temos que descobrir como tiramos um valor imaginário e alimentamos ele com uma função que recebe um valor normal e retorna um imaginário. Nós fazemos isso mantendo em mente que um valor [code]Maybe[/code] representa um cálculo que pode ter falhado.

Você pode estar se perguntado, como é que isso é útil? Pode parecer que applicative functors são mais fortes que monads, desde de que applicative functors nós permitem ter uma função normal para faze-la funcionar operando em valores com contextos. Vamos ver o que monads podem fazer isso também, porque eles são uma atualização de applicative functors, e que eles também podem fazer alguma coisa legal que [applicative functors não podem.

Iremos voltar para [code]Maybe[/code] em um minuto, mas primeiro, vamos verificar que tipo de classe pertence a monads.