title: Mapas e filtros

text: [fuction]map[/function] recebe uma funçãoe e uma lista e aplica esta função em todos elementos da lista, produzindo uma nova lista. Vamos ver como este tipo de declaração é e como isto é definido.

A declaração de tipo nos diz que esta função recebe um [code]a[/code] e retorna um [code]b[/code], uma lista de [code]a[/code]'s e retorna uma lista de [code]b[/code]'s. O interessante aqui é dar uma olhada na assinatura de tipos da função, você pode algumas vezes ver como isto funciona. [code]map[/code] é realmente uma das mais versáteis funções de ordem superior que poderemos utilizar em milhares de formas diferentes. Veja isto em ação:

Você provavelmente já sabe que cada um deles pode ser realizado com uma compreensão de lista. [code]map (+3) [1,5,3,1,6][/code] é o mesmo que escrever [code][x+3 | x &lt;- [1,5,3,1,6]][/code]. Tanto faz, utilizar [code]map[/code] é muito mais legível em muitas situações onde você só pode aplicar alguma função em um elemento da lista, especialmente depois que você estiver lidando com mapas de mapas ter que lidar com uma série de colchetes pode ser um pouco bagunçado.

[fuction]filter[/code] é uma função que recebe um predicado (um predicado é uma função que diz que qualquer coisa é verdadeira ou não, nesse caso, uma função que retorna um valor booleano) e uma lista e então retorna uma lista com elementos que satisfazem o predicado. A declaração de tipo e a implementação pode ser a seguinte:

Bastante simples. Se [code]p x[/code] se transformar em [code]True[/code], o elemento será incluido em uma nova lista. Se isto não acontecer, ficará de fora. Alguns exemplos úteis:

Tudo isto pode ser obtido com uma compreensão de lista e pelo uso de predicados. Não há um conjunto de regras para quando devemos utilizar [code]map[/code] e [code]filter[/code] ao invés de compreensão de lista, você só deve decidir qual será o mais légível dependendo do código e do contexto. O [code]filter[/code] equivale a aplicar diversos predicados em uma compreensão de lista e equivalente a filtrar algo diversas vezes ou juntar o predicado coerentemente com a função [code]&amp;&amp;[/code].

Lembra da função quicksort do <a href="recursion">capítulo anterior</a>? Utilizamos compreensão de lista para filtar os elementos que fosse menor do que (ou igual a) e maior do o pivô. Podemos obter a mesma funcionalidade de um jeito mais legível com o uso do [code]filter[/code]:

Mapeamento e filtragem é o pão e a manteiga de toda a caixa de ferramenta da programação funcional. Não importa se fizermos isso com [code]map[/code] e [code]filter[/code] funções ou compreensão de lista. Lembre-se como resolvemos o problema para achar o triângulo retângulo com um determinada circunferência. Com programação imperativa, nós deveriamos resolve-lo aninhando três loops e então testando se a combinação atual satifaz o triângulo retângulo e se tem o perímetro certo. Se fosse este o caso, teriamos que mostrá-lo na tela ou algo assim. Na programaçõ funcional, os padrões são obtidos com mapeamentos e filtragens. Você faz uma função que recebe um valor e produz algum resutado. Nós mapeamos esta função mais uma lista de valores e então nós filtramos o resultado da lista para que os resultados satisfaçam a nossa busca. Graças à preguiça de Haskell, sempre que você mapear algo sobre uma lista várias vezes e filtrá-la várias vezes, ele só irá passar pela lista uma vez.

Vamos <em>encontrar o maior número em 100.000 que é divisível por 3829</em>. Para fazer isso, vamos filtrar um conjunto de possibilidades em que nós sabemas que a solução consiste.

Primeiro vamos fazer uma lista com todos os números menores do que 100.000, em ordem decrescente. Então vamos filtra-lo pelo seu predicado e como os números são ordenados de forma decrescente, o maior número que irá satisfazer nosso predicado será o primeiro elemento filtrado da lista. Não precisamos utilizar uma lista infinita para o nosso conjunto inicial. Eis a preguiça em ação novamente. Como nós acabamos utilizando a <>ciabeça</i> da lista filtrada, não importa se a lista filtrada for finita ou inifinita. A análise para quando a primeira solução adequada for encontrada.

E agora, nós queremos <em>obter a soma de todos os quadrados ímpares que sejam menores do que 10.000</em>. Primeiramente, como iremos usa-lo em nossa solução, irei introduzir aqui a função [function]takeWhile[/function]. Ele recebe um predicado e uma lista e então vai para o inicio da lista e retorna os elementos que satisfazem o predicado. Se o elemente encontrado por ele não satisfazer o predicado, ele para. Se você quer a primeira palavra da string [code]"elefantes é que sabem fazer festa"[/code], então faça [code]takeWhile (/=' ') "elefantes é que sabem fazer festa"[/code] e ele lhe retornará [code]"elefantes"[/code]. Beleza. A soma de todos os quadrados ímpares que são menores do que 10.000. Primeiramente, vamos começar mapeando a função [code](^2)[/code] em uma lista infinita [code][1..]][/code]. Então filtramos somente os ímpares. E agora, vamos pegar os elementos a partir desta lista que tem todos os menores do 10.000. Finalmente, vamos ter a soma de toda essa lista. Nem sempre precisamos definir uma função para isso, vamos fazer direto em uma linha no GHCI:

Demais! Começamos com alguns dados iniciais (a lista infinita de todos os números naturais) e então nós mapeamos isto, filtramos e cortamos até que fosse o que precisavamos e depois nós somamos. Também podemos escrever isto utilizando compreensão de lista: 

É uma questão de gosto escolher a que você achar mais bonita. Novamente, a magnifica preguiça do Haskell torna isto possível. Nós podemos mapear e filtra uma lista infinita, justamente porque ele não mapeia e filtra do jeito certo, senão essa tarefa seria bem demorada. Somente quando forçamos o Haskell a mostrar para nós a soma realizada na função [code]sim[/code] digamos para o [code]takeWhile[/code] que ele precisa de alguns números. [code]takeWhile[/code] força que o mapeamento e a filtragem ocorrá, porém somente se algum número maior ou igual do que 10.000 for encontrado.

Nossa próximo problema, será lidar com a <a href="http://pt.wikipedia.org/wiki/Conjectura_de_Collatz" target="_blank">sequência de Collatz</a>. Nós pegamos um número. Se ele for par, dividimos por dois. Se for ímpar, dividimos ele por 3 e somamos com mais 1. Pegamos o número resultante e aplicamos a mesma coisa nele, produzindo um novo número e assim por diante. Na essência, nós temos uma sequência de números. Isto é feito para todos os números iniciais, a sequência termina no número 1. Então se tivermos inicialmente o número 13, teremos esta sequência: <i>13, 40, 20, 10, 5, 16, 8, 4, 2, 1</i>. 13*3 + 1 igual a 40. 40 dividido por 2 é 20, etc. Como vimos a sequência tem 10 termos.

Agora o que nós queremos saber é: <em> para todos os números iniciais entre 1 e 100, quantas sequências tem com um length maior do que 15?</em> Primeiramente, vamos escrever uma função para obter uma sequência:

Como a sequência termina em 1, esse seria o caso de limite. Essa é uma função recursiva bem padrão.

Feito! Esta funcionando corretamente. E agora, a função para nos dizer a resposta para a nossa questão:

Mapeamos a função [code]chain[/code] no [code][1..100][/code] para obter uma lista das sequências, com eles mesmos representando-se como listas. Então filtramos eles com o predicado só para verificar se aquelas listas tem o lenght maior do que 15. Novamente nós filtramos, e consguimos ver quantas sequências são deixadas na lista resultante.

<em>Nota:</em> Esta função tem o tipo [code]numLongChains :: Int[/code] porque [code]length[/code] retorna um [code]Int[/code] ao invés de um [code]Num a[/code] por razões históricas. Se quisermos retornar um [code]Num a[/code] mais geral, nós deveremos usar o [code]fromIntegral[/code] no length resultante.