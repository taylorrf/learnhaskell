title: Reader? Ugh, not this joke again.

text: In the <a href="functors-applicative-functors-and-monoids">chapter about applicatives</a>, we saw that the function type, [code](-&gt;) r[/code] is an instance of [code]Functor[/code]. Mapping a function [code]f[/code] over a function [code]g[/code] will make a function that takes the same thing as [code]g[/code], applies [code]g[/code] to it and then applies [code]f[/code] to that result. So basically, we're making a new function that's like [code]g[/code], only before returning its result, [code]f[/code] gets applied to that result as well. For instance:

We've also seen that functions are applicative functors. They allow us to operate on the eventual results of functions as if we already had their results. Here's an example: 

The expression [code](+) &lt;$&gt; (*2) &lt;*&gt; (+10)[/code] makes a function that takes a number, gives that number to [code](*2)[/code] and [code](+10)[/code] and then adds together the results. For instance, if we apply this function to [code]3[/code], it applies both [code](*2)[/code] and [code](+10)[/code] to [code]3[/code], giving [code]6[/code] and [code]13[/code]. Then, it calls [code](+)[/code] with [code]6[/code] and [code]13[/code] and the result is [code]19[/code].

Not only is the function type [code](-&gt;) r[/code] a functor and an applicative functor, but it's also a monad. Just like other monadic values that we've met so far, a function can also be considered a value with a context. The context for functions is that that value is not present yet and that we have to apply that function to something in order to get its result value.

Because we're already acquainted with how functions work as functors and applicative functors, let's dive right in and see what their [code]Monad[/code] instance looks like. It's located in [code]Control.Monad.Instances[/code] and it goes a little something like this:

We've already seen how [code]pure[/code] is implemented for functions, and [code]return[/code] is pretty much the same thing as [code]pure[/code]. It takes a value and puts it in a minimal context that always has that value as its result. And the only way to make a function that always has a certain value as its result is to make it completely ignore its parameter.

The implementation for [code]&gt;&gt;=[/code] seems a bit cryptic, but it's really not all that. When we use [code]&gt;&gt;=[/code] to feed a monadic value to a function, the result is always a monadic value. So in this case, when we feed a function to another function, the result is a function as well. That's why the result starts off as a lambda. All of the implementations of [code]&gt;&gt;=[/code] so far always somehow isolated the result from the monadic value and then applied the function [code]f[/code] to that result. The same thing happens here. To get the result from a function, we have to apply it to something, which is why we do [code](h w)[/code] here to get the result from the function and then we apply [code]f[/code] to that. [code]f[/code] returns a monadic value, which is a function in our case, so we apply it to [code]w[/code] as well.

If don't get how [code]&gt;&gt;=[/code] works at this point, don't worry, because with examples we'll see how this is a really simple monad. Here's a [code]do[/code] expression that utilizes this monad:

This is the same thing as the applicative expression that we wrote earlier, only now it relies on functions being monads. A [code]do[/code] expression always results in a monadic value and this one is no different. The result of this monadic value is a function. What happens here is that it takes a number and then [code](*2)[/code] gets applied to that number and the result becomes [code]a[/code]. [code](+10)[/code] is applied to the same number that [code](*2)[/code] got applied to and the result becomes [code]b[/code]. [code]return[/code], like in other monads, doesn't have any other effect but to make a monadic value that presents some result. This presents [code]a+b[/code] as the result of this function. If we test it out, we get the same result as before:

Both [code](*2)[/code] and [code](+10)[/code] get applied to the number [code]3[/code] in this case. [code]return (a+b)[/code] does as well, but it ignores it and always presents [code]a+b[/code] as the result. For this reason, the function monad is also called the reader monad. All the functions read from a common source. To illustrate this even better, we can rewrite [code]addStuff[/code] like so:

We see that the reader monad allows us to treat functions as values with a context. We can act as if we already know what the functions will return. It does this by gluing functions together into one function and then giving that function's parameter to all of the functions that it was glued from. So if we have a lot of functions that are all just missing one parameter and they'd eventually be applied to the same thing, we can use the reader monad to sort of extract their future results and the [code]&gt;&gt;=[/code]implementation will make sure that it all works out.