title: Primeiras funções do seu filho

text: No capítulo anterior nós aprendemos a idéia basica para chamada de funções. Agora vamos tentar fazer a nossa própria! Abra o seu editor de texto favorito e escreva a seguinte função que recebe um número e o multiplica por dois.

Funções são definidas de forma semelhante como são chamadas. O nome da função é seguido por parâmetros separados por espaços. Porém quando definimos funções, terá um <span class="fixed">=</span> e depois nós iremos definir o que a função faz. Salve isto como <span class="fixed">baby.hs</span> ou algo parecido. Agora vá até o local onde o arquivo foi salvo e rode o <span class="fixed">ghgi</span> a partir dai. Dentro do GCHI, digite <span class="fixed">:l baby</span>. Agora o script estará carregado e nós já podemos brincar com a função que definimos.

Como o <span class="fixed">+</span> funciona muito bem com números inteiros bem como com os números de ponto flutuante (ou qualquer outra coisa que pode ser considerada um número) a nossa função também funcionára com qualquer número. Vamos fazer uma função que recebe dois números e multiplica cada um deles por dois, e após realiza a soma deles. 

Simples. Nós podemos definir isso também como <span class="fixed">doubleUs x y = x + x + y + y</span>. Testar isto produzirá um resultado bastante previsível (lembre-se de anexar esta função no arquivo <span class="fixed">baby.hs</span>, salva-lo e então rodar <span class="fixed">:l baby</span> dentro do GHCI).

Como esperado, você pode chamar suas próprias funções de outras funções que você fez. Com isto em mente, nós iremos redefinir <span class="fixed">doubleUs</span> da seguinte forma:

Este é um exemplo bastante simples de um padrão comum que você verá ao longo de Haskell. Ir fazendo funções básicas que são obviamente corretas e então combina-las em funções mais complexas. Deste forma você também acabará evitando repetições. E se alguns matemáticos descobrissem que 2 é na verdade 3 e você tivesse que mudar o seu programa? Você deveria então simplesmente redefinir o <span class="fixed">doubleMe</span> para ser <span class="fixed">x + x + x</span> e desde que <span class="fixed">doubleUs</span> chamasse <span class="fixed">doubleMe</span>, já estaria funcionando automaticamente neste estranho mundo onde 2 é 3.

Funções em Haskell não precisam estar em um ordem em particular, portanto não importa se você definir primeiro o <span class="fixed">doubleMe</span> e depois o <span class="fixed">doubleUs</span> ou se fizer o contrário.

Agora vamos fazer uma função que multiplicará um número por 2 porém somente se este número for menor ou igual a 100, porque números maiores que 100 já são grandes o suficiente.

Neste ponto iremos introduzir o comando <i>if</i> do Haskell. Você provavelmente esta familiarizado com o comando <i>if</i> de outras linguagens. A diferença entre o comando <i>if</i> do Haskell e o comando <i>if</i> das linguagens imperativas é que a parte do <i>else</i> é obrigatória em Haskell. Em linguagens imperativas você pode simplesmente pular uma séria de etapas se a condição do <i>if</i> não for satisfatória, porém em Haskell toda expressão e função devem retornar alguma coisa. Poderíamos também escrever o comando <i>if</i> em uma só linha, mas eu acho esta forma mais legível. Outra coisa sobre o comando <i>if</i> em Haskell é que ele é uma <i>expressão</i>. Uma <i>expressão</i> é basicamente um pedaço de código que retorna um valor. <span class="fixed">5</span> é uma expressão porque isto retorna 5, <span class="fixed">4 + 8</span> é uma expressão, <span class="fixed">x + y</span> é uma expressão porque retorna a soma de <span class="fixed">x</span> e <span class="fixed">y</span>. Por causa do <i>else</i> ser obrigatório, um <i>if</i> sempre retornará alguma coisa porque ele é uma <i>expressão</i>. Se quisermos adicionar 1 para cada número que será produzido na nossa função anterior, podemos escrevê-la da seguinte forma.

Se tivessemos omitido os parênteses ele teria adicionado 1 somente se <span class="fixed">x</span> não fosse maior do que 100. Note o <span class="fixed">'</span> no final do nome da função. Aquela apóstrofe tem nenhum significado especial na sintaxe do Haskell. Ele é um caracter válido para ser usado em um nome de função. Normalmente nós utilizamos o <span class="fixed">'</span> para designar uma versão especifica de uma função (aqueles que não são preguiçosos) ou em uma versão levemente modificada de uma função ou variável. Pelo fato do <span class="fixed">'</span> ser um caracter válido em funções, nós podemos fazer uma função como esta:

Há duas observações bem interessantes aqui. A primeira é que no nome da função nós não podemos escrever o nome próprio Conan's em letras maiúsculas. Isto porque funções não podem começar com letras maíúsculas. Veremos o porque disto mais adiante. A segunda observação é que esta função não tem nenhum parâmetro. Quando uma função não tem nenhum parâmetro, nós normalmente chamamos isto de <i>definição</i> (ou um <i>nome</i>). Como não podemos alterar o que os nomes (e funções) significam após termos os definido, <span class="fixed">conanO'Brien</span> e a string <span class="fixed">"It's a-me, Conan O'Brien!"</span> podem ser usadas alternadamente.