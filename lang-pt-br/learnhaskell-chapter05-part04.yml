title: Quick, sort!

text: Nós temos uma lista de itens que podem ser ordenados. Seu tipo é uma instância da typeclass [code]Ord[/code]. E agora, nós queremos ordená-los! Existe um algoritmo muito legal para ordenação chamado quicksort. É uma maneira muito esperta de ordenar itens. Se para implementá-lo em uma linguagem imperativa precisa-se de 10 ou mais linhas, a implementação é muito mais curta e elegante em Haskell. O Quicksort se tornou algo como um garoto propaganda para Haskell. Portanto, vamos implementá-lo aqui, mesmo sabendo que implementar quicksort em Haskell é considerado bobagem, já que todos o fazem para mostrar o quão elegante é a linguagem.

Então, a assinatura de tipo será [code]quicksort :: (Ord a) =&gt; [a] -&gt; [a][/code]. Sem surpresas por aqui. A condição limite? Lista vazia, como esperado. Uma lista vazia ordenada é uma lista vazia. Agora aqui vem o algoritmo principal: <em>uma lista ordenada é uma lista que tem todos os valores menores (ou iguais) que a cabeça da lista no início (e esses valores estão ordenados), então vem a cabeça da lista no meio e então vêm todos os valores que são maiores que a cabeça (e eles também estão ordenados).</em> Note que nós dissemos <i>ordenados</i> duas vezes nessa definição, então provavelmente teremos de fazer a chamada recursiva duas vezes! Também note que nós definimos isso usando o verbo <i>ser</i> para definir o algoritmo em vez de dizer <i>faça isto, faça aquilo, então faça aquilo ...</i>. Essa é a beleza da programação funcional! Como vamos filtrar a lista de forma que peguemos apenas os elementos menores que a cabeça da nossa lista e somente os elementos maiores? Compreensão de lista. Então, vamos definir essa função.




Façamos uma pequena rodada de testes para ver se ela parece estar se comportando corretamente.



Booyah! É disso que estou falando! Então se nós temos, digamos, [code][5,1,9,4,6,7,3][/code] e queremos ordenar isso, esse algoritmo primeiro pegará a cabeça, que é [code]5[/code] e então a porá no meio de duas listas que são menor e maior que ela. Então, você terá [code][1,4,3] ++ [5] ++ [9,6,7][/code]. Nós sabemos que, uma vez que a lista esteja completamente ordenada, o número [code]5[/code] ficará na quarta posição, já que há 3 números menores que ele e 3 números maiores que ele. Agora, se nós ordenarmos [code][1,4,3][/code] e [code][9,6,7][/code], nós teremos uma lista ordenada! Ordenamos as duas listas usando a mesma função. Eventualmente, quebraremos a lista tantas vezes que chegaremos à lista vazia e uma lista vazia é já uma lista ordenada, por ser justamente vazia. Aqui está uma ilustração:



Um elemento que está no seu lugar e não vai se mover mais é representado pela cor [code]laranja[/code]. Se você lê-los da esquerda para a direita, verá a lista ordenada. Apesar de nós termos escolhido comparar todos os elementos com a cabeça, nós poderíamos ter usado qualquer outro elemento. No quicksort, um elemento com o qual você compara todos os elementos é chamado de pivô. Eles estão em [code]verde[/code] aqui. Nós escolhemos a cabeça porque é fácil pegá-la através do reconhecimento de padrões. Os elementos que são menores que o pivô estão em [code]verde claro[/code] e os elementos maiores que o pivô estão em [code]verde escuro[/code]. Aquela coisa num gradiente amarelado representa um aplicação do quicksort.
