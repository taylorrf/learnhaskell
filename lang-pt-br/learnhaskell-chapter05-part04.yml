title: Ordem, rápido!

text: Vamos supor que temos uma lista de itens que podem ser ordenados. Seu tipo é uma instância da 
typeclass [code]Ord[/code] e agora queremos ordená-los! Existe um algoritmo muito legal para ordenação 
chamado <a href="http://pt.wikipedia.org/wiki/Quicksort" target="_blank">quicksort</a>. Que é uma maneira 
muito inteligente de ordenar itens. Para implementar ele em uma linguagem imperativa geralmente precisamos 
de 10 ou mais linhas, enquanto que em Haskell além de mais curta, será mais elegante. 
O quicksort se tornou um tipo de garoto propaganda do Haskell. Portanto, vamos implementá-lo, mesmo 
sabendo que fazer o quicksort em Haskell é considerado jogo sujo.

Então, a nossa declaração de tipo será [code]quicksort :: (Ord a) =&gt; [a] -&gt; [a][/code]. 
Nada de novo. A condição limite? Lista vazia, como já esperado. Uma lista vazia ordenada é uma lista 
vazia. Agora vem o algoritmo principal: <em>uma lista ordenada é uma lista composta de uma outra lista 
ordenada até um elemento X de valores menores que X, seguido de outra lista ordenada de valores maiores 
que X.</em> Note que falamos de <b>duas</b> listas <i>ordenadas</i>, então provavelmente teremos que fazer 
uma chamada recursiva duas vezes! Note ainda que usamos o termo <b>é</b> para definir o algoritmo em vez 
de dizer <i>faz isto, faz aquilo, então faz aquele outro...</i>. Essa é a beleza da programação funcional! 
Mas como vamos filtrar a lista para somente obter elementos menores que a cabeça da nossa lista e 
somente elementos maiores que ela? Compreensão de listas. Vamos então definir logo de uma vez essa função.


Vamos fazer uma pequena rodada de testes para ver se ela está se comportando corretamente.


É isso ai! Era disso que eu tava falando! Então se a gente tiver algo como [code][5,1,9,4,6,7,3][/code] e 
quiser ordenar isso, o algoritmo primeiro pegará o primeiro elemento que é [code]5[/code] e colocará ele entre 
as listas de números menores e de números maiores. Assim, você passará a ter [code][1,4,3] ++ [5] ++ [9,6,7][/code]. 
Nós sabemos que uma vez a lista esteja completamente ordenada, o número [code]5[/code] ficará na quarta posição, 
já que há 3 números menores que ele e 3 números maiores que ele. Agora basta ordenarmos [code][1,4,3][/code] e 
[code][9,6,7][/code] para termos uma lista ordenada! Ordenamos as duas listas usando a mesma função. 
Eventualmente, quebraremos a lista tantas vezes que chegaremos a uma lista vazia que, pela nossa 
definição, já é uma lista ordenada. Aí vai uma ilustração:


Um elemento que já encontrou seu lugar final é representado pela cor [orange]laranja[/code]. Se você 
lê-los da esquerda para a direita, verá a lista ordenada. Apesar de nós termos escolhido comparar todos 
os elementos com o primeiro, poderíamos ter usado qualquer outro elemento. No quicksort, o elemento 
que você irá comparar é chamado de pivô. Ele aqui esta em [green]verde[/code]. 
Nós escolhemos o primeiro porque é mais fácil de pegar usando pattern matching. Os elementos que são 
menores que o pivô estão em [green_light]verde claro[/code] e os elementos maiores que o pivô estão em 
[green_bold]verde escuro[/code]. E aquele negócio amarelo no meio de tudo representa a execução do quicksort.
