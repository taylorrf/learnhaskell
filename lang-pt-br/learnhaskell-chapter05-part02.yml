title: Maximum, impressionante

text: A função [code]maximum[/code] recebe uma lista de coisas que podem ser ordenadas (por exemplo, instâncias da typeclass [code]Ord[/code]) e retorna a maior delas. Pense como você implementaria isso numa forma imperativa. Você provavelmente criaria uma variável para guardar o valor máximo encontrado até então e aí você percorreria cada um dos elementos da lista e se um elemento for maior que o máximo, você o substituiria pelo elemento. O máximo que permanecesse no fim seria o resultado. Whew! É uma boa quantidade de palavras para descrever um algorítmo tão simples!

Agora vejamos como o definiríamos recursivamente. Poderíamos primeiro definir uma condição limite e dizer que o máximo de uma lista de um só elemento é igual ao único elemento dela. Então nós podemos dizer que o máximo de uma lista maior é a cabeça se a cabeça for maior que o máximo da calda. Se o máximo da calda é maior, bem, então será o máximo da calda. É isso! Agora vamos implementar isso em Haskell.



Como você pode ver, o reconhecimento de padrões e recursão formam uma grande dupla! A maior parte das linguagens imperativas não tem reconhecimento de padrões, o que leva você a criar muitas construções if else para testar as condições limite. Aqui, nós simplesmente as colocamos como padrões. Então a primeira condição limite diz que se uma lista está vazia, crash! Faz sentido porque o que é o máximo de um lista vazia? Eu não sei. O segundo padrão também funciona como uma condição limite. Ele diz que se a lista tem apenas um único elemento, deve-se apenas retornar o único elemento.

Agora, o terceiro padrão é onde a ação acontece. Nós usamos o reconhecimento de padrões para dividir a lista numa cabeça e numa calda. É um idioma muito comum quando fazendo recursão com listas, então acostume-se a ele. Nós usamos uma ligação <i>where</i> para definir [code]maxTail[/code] como o máximo do resto da lista. Então nós checamos se a cabeça é maior que o máximo do resto da lista. Se ela é, nós retornamos a cabeça. Se não, nós retornamos o máximo do resto da lista.

Peguemos o exemplo de uma lista de números e vejamos como isso funcionaria neles: [code][2,5,1][/code]. Se nós chamarmos [code]maximum'[/code] nela, os primeiros dois padrões não vão combinar. O terceiro irá, e a lista será então dividida em [code]2[/code] e [code][5,1][/code]. A cláusula <i>where</i> quer saber o máximo de [code][5,1][/code], e então nós seguimos por esse caminho. Ela combina com o terceiro padrão novamente e [code][5,1][/code] é dividido novamente em [code]5[/code] e [code][1][/code]. Novamente, a  cláusula [code]where[/code] quer saber o máximo de [code][1][/code]. Como essa é a condição limite, ela retorna [code]1[/code]. Finalmente! Então subindo um passo, comparando [code]5[/code] com o máximo de [code][1][/code] (que é [code]1[/code]), nós obviamente chegamos a [code]5[/code]. Então agora nós sabemos que o máximo de [code][5,1][/code] é [code]5[/code]. Nós subimos um passo novamente, onde nós tínhamos [code]2[/code] and [code][5,1][/code]. Comparando [code]2[/code] com o máximo de [code][5,1][/code], que é [code]5[/code], nós escolhemos [code]5[/code].

Uma forma ainda mais clara de escrever essa função é usando [code]max[/code]. Se você lembra, [code]max[/code] é uma função que pega dois números e retorna o maior deles. Aqui está como nós poderíamos reescrever [code]maximum'[/code] usando [code]max[/code]:

Quanta elegância! Em essência, o máximo de uma lista é o maior entre primeiro elemento e o máximo da calda.
