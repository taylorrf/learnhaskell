title: Arquivos e streams

text: [code]getChar[/code] é uma ação de E/S que lê um único caractere do terminal. [code]getLine[/code] é uma ação de E/S que lê uma linha do terminal. As duas são bem diretas e maioria das linguagens de programação tem algumas funções ou declarações que são similares a elas. Mas agora, vamos conhecer [function]getContents[/function]. [code]getContents[/code] é uma ação de E/S que lê qualquer coisa do dispositivo de entrada padrão até encontrar um caractere de fim de arquivo. Seu tipo é [code]getContents :: IO String[/code]. O que é legal em [code]getContents[/code] é que ela faz E/S preguiçosa. Quando escrevemos [code]foo &lt;- getContents[/code], ela não lê toda a entrada de uma vez, armazena na memória e associa a [code]foo[/code]. Não, ela é preguiçosa! Ela dirá: <i>"Sim sim, eu vou ler a entrada do terminal mais tarde a medida em que avançamos, quando você realmente precisar dela!"</i>.

[code]getContents[/code] é realmente útil quando estamos fazendo piping da saída de um programa para a entrada do nosso programa. Caso você não saiba como piping funciona em sistemas baseados em unix, aqui vai uma explicação rápida. Vamos criar um arquivo de texto que contém o seguinte pequeno haicai:

Sou um pequeno bule
O que há com essa comida de avião, hein?
Ela é tão pequena, sem gosto

Sim, o haicai é uma porcaria, e daí? Se alguém souber de algum bom tutorial de haicai, compartilhe comigo.

Agora, relembre o pequeno programa que escrevemos quando estávamos apresentando a função [code]forever[/code]. Ele aguardava que o usuário digitasse uma linha, retornava essa linha para ele em MAIÚSCULAS e depois fazia tudo de novo, indefinidamente. Só para você não ter que voltar tudo de novo, aqui está ele novamente:

Iremos salvar esse programa como [code]capslocker.hs[/code] ou algum outro nome e compilá-lo. Depois, vamos usar um pipe unix para passar nosso arquivo de texto diretamente para o nosso pequeno programa. Vamos ter o auxílio do programa GNU <i>cat</i>, que imprime um arquivo que lhe é dado como argumento. Dê uma olhada, é excelente!

Como você pode observar, o piping da saída de um programa (no nosso caso do <i>cat</i>) para a entrada de outro (<i>capslocker</i>) é feito com o caractere [code]|[/code]. O que fizemos é equivalente a simplesmete executar <i>capslocker</i>, digitando nosso haicai no terminal e depois fornecendo um caractere de fim de arquivo (isso normalmente é feito pressionando Ctrl-D). Isso é como executar <i>cat haiku.txt</i> e dizer: &ldquo;Espera, não imprima isso no terminal, passe para <i>capslocker</i> ao invés disso!&rdquo;.

Então o que essencialmente estamos fazendo com esse [code]forever[/code] é pegar a entrada e transformá-la em alguma saída. Por isso nos podemo usar [code]getContents[/code] para tornar nosso programa ainda melhor e mais curto:

Nós executamos a ação de E/S [code]getContents[/code] e chamamos a string que ela produz de [code]contents[/code]. Então, usamos [code]toUpper[/code] para mapear essa string e imprimí-la no terminal. Tenha em mente que devido às strings serem basicamente listas, que são preguiçosas, e [code]getContents[/code] ser E/S preguiçosa, o programa não tentará ler todo o conteúdo de uma vez e guardá-lo na memória antes de imprimir a versão em maiúsculas. Ao invés disso, ele imprimirá a versão em maiúsculas à medida que faz a leitura, porque ele somente lerá uma linha da entrada quando realmente precisar.

Legal, isso funciona. O que acontece se simplesmente executarmos <i>capslocker</i> e tentarmos digitar as linhas no terminal?

Nós encerramos pressionando Ctrl-D. Muito bom! Como você pode perceber, ele imprime nossa saída em maiúsculas linha por linha. Quando o resultado de [code]getContents[/code] é associado a [code]contents[/code], ele não é representado na memória como uma string real, mas como uma promessa de que irá produzir aquela string eventualmente. Quando usamos [code]toUpper[/code] para mapear [code]contents[/code], isso também é uma promessa de usar essa função para mapear um possível conteúdo dessa string. E finalmente quando [code]putStr[/code] acontece, ela diz para a promessa anterior: <i>"Ei, eu preciso de uma linha em maiúsculas!"</i>. Ela não tem linhas ainda, então diz para [code]contents[/code]: <i>"Ei, que tal agora pegar uma linha do terminal?"</i>. É aí que  [code]getContents[/code] realmente lê do terminal e fornece uma linha para o código que pediu a ela para produzir algo real. Esse código então usa [code]toUpper[/code] para mapear a linha e passa ela para [code]putStr[/code], que a imprime. Depois, [code]putStr[/code] says: <i>"Ei, eu preciso da próxima linha, vamos!"</i> e isto se repete até que não haja mais entradas, o que é verificado pela presença de um caractere de final de arquivo.

Vamos criar um programa que recebe alguma entrada e imprime somente as linhas que têm menos de 15 caracteres. Observe:

Fizemos a parte de E/S do nosso programa o menor possível. Devido ao fato de que o nosso programa deve ler uma entrada e imprimir alguma saída baseada nessa entrada, podemos implementá-lo lendo o conteúdo da entrada, aplicando uma função sobre eles e depois imprimindo o que a função retornou.

A função [code]shortLinesOnly[/code] funciona dessa forma: ela recebe uma string, como [code]"short\nlooooooooooooooong\nshort again"[/code]. Essa string tem três linhas, duas delas são curtas e a do meio é longa. Ela aplica a função [code]lines[/code] nessa string, convertendo-a em [code]["short", "looooooooooooooong", "short again"][/code], que depois associamos ao nome [code]allLines[/code]. Essa lista de string é então filtrada de modo que somente aquelas linhas que são têm menos de 15 caracteres permanecem na lista, produzindo [code]["short", "short again"][/code]. E finalmente, [code]unlines[/code] junta essa lista em uma única string com quebras de linha, obtendo [code]"short\nshort again"[/code]. Vamos testá-la.

i'm short
so am i
i am a loooooooooong line!!!
yeah i'm long so what hahahaha!!!!!!
short line
loooooooooooooooooooooooooooong
short

Fazemos um pipe do conteúdo de <i>shortlines.txt</i> para a entrada de <i>shortlinesonly</i> e como saída, obtemos somente as linhas curtas.

Esse padrão de obter alguma string do dispositivo de entrada, transformá-la com uma função e depois imprimí-la é tão comum que existe uma função, chamada [function]interact[/function], que torna sua implementação ainda mais fácil. [code]interact[/code] recebe uma função do tipo [code]String -&gt; String[/code] como parâmetro e retorna uma ação de E/S que irá receber alguma entrada, aplicar a função nela e depois imprimir o resultado da função. Vamos modificar o nosso programa para usá-la.

Só para mostar como esse resultado pode ser alcançado com muito menos código (mesmo achando que será menos legível) e para demonstrar nossa habilidade com composição de funções, vamos retrabalhá-lo mais um pouco.

Wow, nós realmente o reduzimos a uma única linha, o que é muito legal!

Até agora, nós trabalhamos com E/S imprimindo coisas no terminal e lendo dele. Mas e quanto a ler e escrever em arquivos? Bem, de certo modo, nós já estamos fazendo isso. Um modo de visualizar a leitura do terminal é imaginar que é como ler de um arquivo (um tanto especial). O mesmo vale para escrever no terminal, que é como escrever em um arquivo. Chamamos esses dois arquivos de [code]stdout[/code] e [code]stdin[/code], que significam <i>saída padrão</i> e <i>entrada padrão</i>, respectivamente. Mantendo isso em mente, veremos que escrever e ler arquivos é muito parecido com escrever na saída padrão e ler da entrada padrão.

Iremos iniciar com um programa realmente simples que abre um arquivo chamado <i>girlfriend.txt</i>, que contém um verso do hit nº 1 de Avril Lavigne, <i>Girlfriend</i>, e somente o imprime no terminal. Aque está <i>girlfriend.txt</i>:

E aqui está o nosso programa:

Executando-o, obtemos o resultado esperado:

Vamos estudá-lo linha a linha. A primeira linha são só quatro exclamações, para atrair sua atenção. Na segunda linha, Avril nos diz que ela não gosta do nosso parceiro romântico atual. A terceira linha serve para enfatizar essa desaprovação, enquando a quarta linha sugere que deveríamos procurar uma nova namorada.

Vamos estudar também o programa linha por linha! Nosso programa são várias ações de E/S unidas por um bloco <i>do</i>. Na primeira linha do bloco <i>do</i>, nós observamos uma nova função chamada [function]openFile[/function]. Esta é sua assinatura de tipo: [code]openFile :: FilePath -&gt; IOMode -&gt; IO Handle[/code]. Se você lê-la em voz alta, ela diz: [code]openFile[/code] recebe um caminho de arquivo e um [code]IOMode[/code] e retorna uma ação de E/S que abrirá um arquivo e terá o handle associado a esse arquivo encapsulado como seu resultado.

[code]FilePath[/code] é só um <a href="making-our-own-types-and-typeclasses#type-synonyms">tipo sinônimo</a> para [code]String[/code], simplesmente definido como:

Exatamente como nosso tipo que representa os sete possíveis valores para os dias da semana, esse tipo é uma enumeração que representa o que nós queremos fazer com nossos arquivos abertos. Muito simples. Só repare que esse tipo é [code]IOMode[/code] e não [code]IO Mode[/code]. [code]IO Mode[/code] seria o tipo de uma ação de E/S que tem um valor de algum tipo [code]Mode[/code] como seu resultado, mas [code]IOMode[/code] é somente uma simples enumeração.

Por fim, é retornada uma ação de E/S que abrirá o arquivo especificado no modo especificado. Se associarmos essa ação a algo obtemos um [code]Handle[/code]. Um valor do tipo [code]Handle[/code] representa onde o nosso arquivo está. Usaremos esse handle para saber de qual arquivo ler. Seria estúpido ler um arquivo e não associá-lo a um handle porque não seríamos capazes de fazer qualquer coisa com o arquivo. Então, no nosso caso, associamos o handle a [code]handle[/code].

Na próxima linha, vemos uma função chamada [function]hGetContents[/function]. Ela recebe um [code]Handle[/code], de forma que ela sabe de qual arquivo obter o conteúdo e retorna uma [code]IO String[/code] &mdash; uma ação de E/S que guarda como seu resultado o conteúdo do arquivo. Essa função é bem parecida com [code]getContents[/code]. A única diferença é que [code]getContents[/code] lerá autometicamente da entrada padrão (que é o terminal), enquanto [code]hGetContents[/code] tem um handle de arquivo que lhe diz de qual arquivo ler. Em todos os outros aspectos, elas funcionam igualmente. E exatamente como [code]getContents[/code], [code]hGetContents[/code] não tentará ler um arquivo de uma vez e guardá-lo na memória, mas ele lerá quando necessário. Isso é bem interessante porque podemos tratar [code]contents[/code] como o conteúdo inteiro do arquivo, mas na verdade ele não está carregado na memória. Então se for um arquivo bem enorme, escrever [code]hGetContents[/code] não iria esgotar sua memória, mas iria ler somente o que precisasse, quando necessário.

Veja a diferença entre o handle usado para identificar um arquivo e o conteúdo de um arquivo, associados no nosso programa a [code]handle[/code] e [code]contents[/code], respectivamente. O handle é somente algo pelo qual nós sabemos o que é o nosso arquivo. Se você pensar em todo seu sistema de arquivos como sendo um livro bem grande e cada arquivo é um capítuo no livro, o handle é um marcador de livros que mostra onde você está lendo atualmente (ou escrevendo) um capítulo, enquanto que o conteúdo é o capítulo real.

Com [code]putStr contents[/code] nós só imprimimos o conteúdo na saída padrão e depois escrevemos [function]hClose[/function], que recebe um handle e retorna uma ação de E/S que fecha o arquivo. Você mesmo tem que fechar o arquivo após abrí-lo com [code]openFile[/code]!

Outra maneira de o que acabamos de fazer é usar a função [function]withFile[/function], que tem a assinatura de tipo [code]withFile :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a[/code]. Ela recebe um caminho para um arquivo, um [code]IOMode[/code] e depois recebe uma função que pega um handle e retorna alguma ação de E/S. O que ela retorna é uma ação de E/S que abre aquele arquivo, faz algo que queremos com ele e depois o fecha. O resultado encapsulado na ação de E/S final que é retornada é o mesmo resultado que a ação de E/S que nós passamos retornaria. Isso pode soar um pouco complicado, mas é muito simples, especialmente com lambdas. Aqui está o nosso exemplo anterior reescrito usando [code]withFile[/code]:

Como você vê, é muito semelhante com o trecho de código anterior. [code](\handle -&gt; ... )[/code] é a função que recebe um handle e retorna uma ação de E/S e ela geralmente é escrita assim, com um lambda. A razão para ela ter que receber uma função que retorna uma ação de E/S ao invés de simplesmente receber uma ação de E/S para executar e depois fechar o arquivo é que a ação de E/S que nós passamos a ela não saberia sobre qual arquivo operar. Desse modo, [code]withFile[/code] abre o arquivo e então passa o handle para a função que demos a ela. Depois pega de volta uma ação de E/S daquela função e cria uma ação de E/S igual, só que fecha o arquivo depois. Eis um modo como podemos fazer a nossa própria função [code]withFile[/code]:

Sabemos que o resultado será uma ação de E/S, então podemos começar com um <i>do</i>. Primeiro abrimos o arquivo e obtemos o handle dele. Depois, passamos [code]handle[/code] para a nossa função para obter uma ação de E/S que faz todo o trabalho. Associamos essa ação a [code]result[/code], fechamos o handle e então escrevemos [code]return result[/code]. Ao usar [code]return[/code] para retornar o valor encapsulado na ação de E/S que obtivemos de [code]f[/code], fizemos com que nossa ação de E/S encapsule o mesmo resultado que a que nós obtivemos de [code]f handle[/code]. Então se [code]f handle[/code] retorna uma ação que leria algumas linhas da entrada padrão, as imprimiria em um arquivo e teria encapsulado como seu resultado o número de linhas que foram lidas, se usássemos ela com [code]withFile'[/code], a ação de E/S resultante também teria como seu resultado o número de linhas lidas.

Exatamente como temos [code]hGetContents[/code] que funciona como [code]getContents[/code] mas para um arquivo específico, também temos [function]hGetLine[/function], [function]hPutStr[/function], [function]hPutStrLn[/function], [function]hGetChar[/function], etc. Elas funcionam exatamente como suas equivalentes sem o <i>h</i>, porém recevem um handle como parâmetro e operam naquele arquivo específico ao invés de operar sobre a entrada padrão ou saída padrão. Exemplo: [code]putStrLn[/code] é uma função que recebe uma string e retorna uma ação de E/S que imprimirá essa string no terminal e criará uma nova linha depois. [code]hPutStrLn[/code] recebe um handle e uma string e retorna uma ação de E/S que escreverá essa string no arquivo associado ao handle e criará uma nova linha depois dessa string. Do mesmo modo, [code]hGetLine[/code] recebe um handle e retorna uma ação de E/S que lê uma linha do seu arquivo.

Abrir arquivos e depois tratar seu conteúdo como strings é tão comum que nós temos essas três pequenas e agradáveis funções que tornam o nosso trabalho ainda mais fácil:

[function]readFile[/function] tem a assinatura de tipo [code]readFile :: FilePath -&gt; IO String[/code]. 
Lembre-se, [code]FilePath[/code] é só um nome fantasia para [code]String[/code]. 
[code]readFile[/code] recebe um caminho para um arquivo e retorna uma ação de E/S que irá ler aquele arquivo (preguiçosamente, é claro) e associar seu conteúdo a algum nome como uma string. Isso é geralmente mais conveniente do que executar [code]openFile[/code], associá-lo a um handle e então executar [code]hGetContents[/code]. Eis um modo como poderíamos ter escrito nosso exemplo anterior com [code]readFile[/code]:

Devido a não obtermos um handle com o qual identificaríamos nosso arquivo, não temos como fechá-lo manualmente, então Haskell faz isso por nós quando usamos [code]readFile[/code].

[function]writeFile[/function] tem o tipo [code]writeFile :: FilePath -&gt; String -&gt; IO ()[/code]. Ela recebe um caminho para um arquivo e uma string para escrever nesse arquivo e retorna uma ação de E/S que fará a escrita. Se o arquivo já existir, ele terá seu conteúdo apagado antes de ser escrita a string nele. Aqui está como transformar <i>girlfriend.txt</i> em uma versão em MAIÚSCULAS e escrevê-la em <i>girlfriendcaps.txt</i>:

[function]appendFile[/function] tem uma assinatura de tipo que é exatamente igual à de [code]writeFile[/code], mas [code]appendFile[/code] não apaga o conteúdo do arquivo se ele já existir, mas acrescenta coisas a ele.

Digamos que nós temos um arquivo <i>todo.txt</i> que em cada linha tem uma tarefa que nós temos que fazer. Agora vamos criar um programa que pega uma linha da entrada padrão e adiciona ela à nossa lista de tarefas.

Precisamos adicionar o [code]"\n"[/code] no final de cada linha porque [code]getLine[/code] não nos dá um caractere de nova linha no final.

Ooh, mais uma coisa. Falamos sobre como escrever [code]contents &lt;- hGetContents handle[/code] não faz o arquivo inteiro ser lido de uma vez e armazenado na memória. A E/S é preguiçosa, então fazer isso:

é como ligar um cano do arquivo até a saída. Exatamente como você pode pensar em listas como streams, você também pode pensar em arquivos como streams. Isso irá ler uma linha de cada vez e imprimí-la no terminal à medida em que a leitura avança. Então você deve estar perguntando, quão largo é esse cano afinal? Com que frequência o disco será acessado? Bem, para arquivos de texto, a bufferização padrão é usualmente bufferização por linha. O que significa que a menor parte do arquivo a ser lida de uma vez é uma linha. Por isso que nesse caso, na verdade, uma linha é lida e impressa na saída, a próxima linha é lida e impressa, etc. Para arquivos binários, a bufferização padrão é geralmente a bufferização por bloco. O que significa que o arquivo será lido bloco a bloco. O tamanho do bloco é algum tamanho que o seu sistema operacional achar razoável.

Você pode controlar exatamente como a bufferização é feita usando a função [code]hSetBuffering[/code]. Ela recebe um handle e um [code]BufferMode[/code] e retorna uma ação de E/S que determina o modo de bufferização. [code]BufferMode[/code] é um tipo de dados simples de enumeração e os possíveis valores que ele pode assumir são: [code]NoBuffering[/code], [code]LineBuffering[/code] ou [code]BlockBuffering (Maybe Int)[/code]. O [code]Maybe Int[/code] serve para especificar o quão grande o bloco deve ser, em bytes. Se for [code]Nothing[/code], então o sistema operacional determina o tamanho do bloco. [code]NoBuffering[/code] significa que será lido um caractere de cada vez. [code]NoBuffering[/code] geralmente é uma porcaria porque tem que acessar o disco com muita frequência.

Aqui está o nosso trecho de código aterior, porém sem ler linha por linha, mas o arquivo inteiro em blocos de 2048 bytes.

Ler arquivos em blocos maiores pode ajudar se quisermos minimizar o acesso ao disco ou quando nosso arquivo é na verdade um recurso de rede lento.

Podemos também usar [function]hFlush[/function], que é uma função que recebe um handle e retorna uma ação de E/S que irá descarregar o buffer do arquivo associado ao handle. Quando estamos usando bufferização por linha, o buffer é descarregado depois de cada linha. Quando usamos bufferização por bloco, descarrega-se quando lemos um bloco. O buffer também é descarregado quando fechamos um handle. Isso significa que quando encontramos um caractere de nova linha, o mecanismo de leitura (ou escrita) transfere todos os dados até o momento. Porém, podemos usar [code]hFlush[/code] para forçar a transferência dos dados que foram lidos até agora. Após descarregar, os dados ficam disponíveis para outros programas que estão rodando ao mesmo tempo.

Pense na leitura de um arquivo bufferizada por bloco como: sua privada está configurada para desccarregar-se assim que tenha quatro litros de água dentro dela. Então você começa a jogar água e uma vez que a marca de quatro litros seja atingida, a água é automaticamente descarregada e a informação na água que você jogou até agora é lida. Porém, você também pode descarregar a privada manualmente pressionando o botão nela. Isso faz a privada descarregar e toda a água (informação) dentro dela é lida. Caso você não tenha percebido, descarregar o vaso manualmente é uma metáfora para [code]hFlush[/code]. Essa não é uma analogia muito boa para os padrões de analogia de programação, mas eu queria um objeto do mundo real que pudesse ser descarregado para exemplificar.

Nós já fizemos um programa para adicionar um novo item à nossa lista de tarefas em <i>todo.txt</i>, agora faremos um programa para remover um item. Eu vou somente colar o código e depois vamos analisar o programa juntos para você ver que ele é muito fácil. Usaremos algumas novas funções de [code]System.Directory[/code] e uma nova função de [code]System.IO[/code], mas elas serão explicadas.

De qualquer modo, aque está o programa para remover um item de <i>todo.txt</i>:

Primeiramente, nós apenas abrimos <i>todo.txt</i> no modo leitura e associamos seu handle a [code]handle[/code]. Depois, usamos uma ação de E/S de [code]System.Directory[/code] chamada [function]getTemporaryDirectory[/function]. Ela é uma ação de E/S que pergunta ao seu sistema operacional qual é o diretório adequado para armazenar um arquivo temporário e retorna isso como seu resultado. Seu tipo é [code]getTemporaryDirectory :: IO String[/code], embora fosse mais claro nesse caso pensar nisso como sendo [code]getTemporaryDirectory :: IO FilePath[/code]. Nós associamos o caminho do diretório temporário a [code]tempdir[/code].

Em seguida, usamos uma função que não conhecíamos de pertence a [code]System.IO[/code] &mdash; [function]openTempFile[/function]. Seu nome é bem auto-explicativo. Ela recebe um caminho para um diretório temporário e um modelo de nome para um arquivo e abre um arquivo temporário. Usamos [code]"temp"[/code] como modelo de nome para o arquivo temporário, o que significa que o arquivo temporário será nomeado <i>temp</i> mais alguns caracteres aleatórios. Ela retorna uma ação de E/S que cria o arquivo temporário e o resultado nessa ação de E/S é um par de valores: o nome do arquivo temporário e um handle. Poderíamos simplesmente abrir um arquivo normal chamado <i>todo2.txt</i> ou algo parecido, mas é uma boa prática usar [code]getTemporaryDirectory[/code] e [code]openTempFile[/code] porque você garantirá que não está sobrescrevendo nada.

Em seguida, associamos o conteúdo de <i>todo.txt</i> a [code]contents[/code]. Depois, dividimos essa string em uma lista de strings, cada uma sendo uma linha. Assim, [code]todoTasks[/code] agora é algo como [code]["Iron the dishes", "Dust the dog", "Take salad out of the oven"][/code]. Nós mesclamos os números de 0 em diante e essa lista com uma função que pega um número, como 3, uma string, como [code]"hey"[/code] e retorna [code]"3 - hey"[/code], assim [code]numberedTasks[/code] é [code]["0 - Iron the dishes", "1 - Dust the dog" ...[/code]. Juntamos essa lista de strings em uma única string com quebras de linha usando [code]unlines[/code] e a imprimimos essa string no terminal. Observe que ao invés de fazer isso, também poderíamos ter feito [code]mapM putStrLn numberedTasks[/code]

Perguntamos ao usuário qual atividade ele quer excluir e esperamos ele digitar um número. Digamos que ele queira excluir a atividade 1, que é [code]Dust the dog[/code], então ele digita [code]1[/code]. [code]numberString[/code] agora é [code]"1"[/code] e porque nós queremos um número, não uma string, aplicamos [code]read[/code] a ela para obter [code]1[/code] e associamos isso a [code]number[/code].

Lembre-se das funções [code]delete[/code] e [code]!![/code] de [code]Data.List[/code]. [code]!![/code] retorna um elemento de uma lista com determinado índice e [code]delete[/code] exclui a primeira ocorrência de um elemento em uma lista e retorna uma nova lista sem aquela ocorrência. [code](todoTasks !! number)[/code] (number agora é [code]1[/code]) retorna [code]"Dust the dog"[/code]. Associamos [code]todoTasks[/code] sem a primeira ocorrência de [code]"Dust the dog"[/code] a [code]newTodoItems[/code] e então juntamos isso em uma única string usando [code]unlines[/code] antes de escrever no arquivo temporário que abrimos. O arquivo antigo está intacto e o arquivo temporário contém todas as linhas que o antigo contém, exceto pela linha que excluímos.

Depois disso fechamos tanto o arquivo original quanto o temporário e então removemos o original com [function]removeFile[/function], que, como você pode ver, recebe um caminho para um arquivo e o exclui. Depois de deletar o antigo <i>todo.txt</i>, usamos [function]renameFile[/function] para renomear o arquivo temporário para <i>todo.txt</i>. Tome cuidado, [code]removeFile[/code] e [code]renameFile[/code] (que estão ambos em [code]System.Directory[/code] a propósito) recebem caminhos para arquivos como parâmetros, não handles.

Assunto encerrado! Poderíamos ter feito isso em ainda menos linhas, mas fomos bem cuidadosos para não sobrescrever algum arquivo existente e educadamente perguntamos ao sistema operacional sobre onde poderíamos colocar nosso arquivo temporário. Agora vamos testar o programa!