title: A palavra chave newtype

Até agora, nós aprendemos como criar tipos de dados algébricos utilizando a palavra chave <em>data</em>. Nós aprendemos também a dar sinônimos para tipos existentes com a palavra chave <em>type</em>. Nesta seção, nós iremos dar uma olhada em como criar novos tipos a partir de tipos de dados já existentes utilizando a palavra chave <em>newtype</em> e porque nós iriamos querer fazer isso em primeiro lugar.

Na seção anterior, nós vimos que há na verdade mais formas do tipo lista ser um applicative functor. Uma delas é [code]&lt;*&gt;[/code] pegar cada função da lista a esquerda e aplicar a cada valor na lista a direita, resultando em todas as combinações possíveis ao aplicar as funções da esquerda com os valores da direita.

A segunda forma é pegar a primeira função a esquerda do [code]&lt;*&gt;[/code] e aplicar ao primeiro valor da direita, então pegar a segunda função da lista a esquerda e aplicar ao segundo valor da direita, e assim por diante. Por fim, é como se estivessemos mesclando as duas listas. Mas listas já são uma instância de [code]Applicative[/code], então como nós fazemos da lista uma instância de [code]Applicative[/code] desta segunda forma? Se você lembra, nós dissemos que o tipo [code]ZipList a[/code] foi introduzido para esse propósito, que tem um construtor, [code]ZipList[/code], que tem apenas um campo. Nós envolvemos a lista no campo. Então, [code]ZipList[/code] se torna uma instância de [code]Applicative[/code], assim quando nós queremos usar listas como aplicatives para realizar mesclagem, nós apenas envolvemos elas com o construtor [code]ZipList[/code] e então uma vez feito, recuperamos elas com [code]getZipList[/code]:

Então, o que isso tem a ver com a palavra-chave <i>newtype</i>? Bem, penso sobre como nós podemos escrever a declaração dos dados para nosso tipo [code]ZipList a[/code]. Uma forma seria fazer assim:

Um tipo que tem apenas um construtor e que o construtor tem apenas um campo que é uma lista de coisas. Nós podemos querer também usar a sintaxe do record onde nós automaticamente obtemos uma função que extrai uma lista de um [code]ZipList[/code]:

Parece bom e funciona muito bem. Nós temos duas forma de fazer um tipo existente uma instância de um tipo de classe, então nós usamos a palavra-chave <i>data</i> para envolver o tipo em outro e fazer desse uma instância desse segunda modo.

A palavra-chave <i>newtype</i> em Haskell é exatamente para estes casos quando nós queremos apenas pegar um tipo e envolver em alguma coisa para aprensentar como outro tipo. Nas bibliotecas atuais, [code]ZipList a[/code] é definido como algo assim:

Ao invés da palavra-chave <i>data</i>, a palavra-chave <i>newtype</i> é usada. Por que motivo? Bem, <i>newtype</i> é rápido. Se você usa a palavra-chave <i>data</i> para envolver um tipo, há um custo ao envolver e recuperar os dados quando seu programa está sendo executado. Mas se você usa <i>newtype</i>, Haskell sabe que você apenas está usando isso para envolver um tipo existente em um novo tipo (portanto o nome), porque você quer que internamente seja a mesma coisa mas tenha um tipo diferente. Com isso em mente, Haskell consegue eliminar o trabalho de envolver e recuperar valores uma vez que este sabe que valor é de que tipo.

Então, porque não usar <i>newtype</i> em todos os casos ao invés de <i>data</i> então? Bem, quando você cria um novo tipo a partir de um tipo existente usando a palavra-chave <i>newtype</i>, você pode ter apenas um construtor e este deve ter apenas um campo. Mas com <i>data</i>, você pode criar tipos de dados com mais de um construtor e cada construtor pode ter zero ou mais campos:

Quando usamos <i>newtype</i>, estamos restritos apenas um construtor com apenas um campo.

We can also use the <i>deriving</i> keyword with <i>newtype</i> just like we would with <i>data</i>. We can derive instances for [code]Eq[/code], [code]Ord[/code], [code]Enum[/code], [code]Bounded[/code], [code]Show[/code] and [code]Read[/code].
If we derive the instance for a type class, the type that we're wrapping has to be in that type class to begin with. It makes sense, because <i>newtype</i> just wraps an existing type. So now if we do the following, we can print and equate values of our new type:

Let's give that a go:

In this particular <i>newtype</i>, the value constructor has the following type:


It takes a [code][Char][/code] value, such as [code]"my sharona"[/code] and returns a [code]CharList[/code] value. From the above examples where we used the [code]CharList[/code] value constructor, we see that really is the case. Conversely, the [code]getCharList[/code] function, which was generated for us because we used record syntax in our <i>newtype</i>, has this type:

It takes a [code]CharList[/code] value and converts it to a [code][Char][/code] value. You can think of this as wrapping and unwrapping, but you can also think of it as converting values from one type to the other.

<h3>Using newtype to make type class instances</h3>


Many times, we want to make our types instances of certain type classes, but the type parameters just don't match up for what we want to do. It's easy to make [code]Maybe[/code] an instance of [code]Functor[/code], because the [code]Functor[/code] type class is defined like this:

So we just start out with:

And then implement [code]fmap[/code]. All the type parameters add up because the [code]Maybe[/code] takes the place of [code]f[/code] in the definition of the [code]Functor[/code] type class and so if we look at [code]fmap[/code] like it only worked on [code]Maybe[/code], it ends up behaving like:

Isn't that just peachy? Now what if we wanted to make the tuple an instance of [code]Functor[/code] in such a way that when we [code]fmap[/code] a function over a tuple, it gets applied to the first component of the tuple? That way, doing [code]fmap (+3) (1,1)[/code] would result in [code](4,1)[/code]. It turns out that writing the instance for that is kind of hard. With [code]Maybe[/code], we just say [code]instance Functor Maybe where[/code] because only type constructors that take exactly one parameter can be made an instance of [code]Functor[/code]. But it seems like there's no way to do something like that with [code](a,b)[/code] so that the type parameter [code]a[/code] ends up being the one that changes when we use [code]fmap[/code]. To get  around this, we can <i>newtype</i> our tuple in such a way that the second type parameter represents the type of the first component in the tuple:

And now, we can make it an instance of [code]Functor[/code] so that the function is mapped over the first component:

As you can see, we can pattern match on types defined with <i>newtype</i>. We pattern match to get the underlying tuple, then we apply the function [code]f[/code] to the first component in the tuple and then we use the [code]Pair[/code] value constructor to convert the tuple back to our [code]Pair b a[/code].
If we imagine what the type [code]fmap[/code] would be if it only worked on our new pairs, it would be:


Again, we said [code]instance Functor (Pair c) where[/code] and so
[code]Pair c[/code] took the place of the [code]f[/code]
in the type class definition for [code]Functor[/code]:


So now, if we convert a tuple into a [code]Pair b a[/code], we can use [code]fmap[/code] over it and the function will be mapped over the first component:


<h3>On newtype laziness</h3>


We mentioned that <i>newtype</i> is usually faster than <i>data</i>. The only thing that can be done with <i>newtype</i> is turning an existing type into a new type, so internally, Haskell can represent the values of types defined with <i>newtype</i> just like the original ones, only it has to keep in mind that the their types are now distinct. This fact means that not only is <i>newtype</i> faster, it's also lazier. Let's take a look at what this means.

Like we've said before, Haskell is lazy by default, which means that only when we try to actually print the results of our functions will any computation take place. Furthemore, only those computations that are necessary for our function to tell us the result will get carried out. The [code]undefined[/code] value in Haskell represents an erronous computation. If we try to evaluate it (that is, force Haskell to actually compute it) by printing it to the terminal, Haskell will throw a hissy fit (technically referred to as an exception):

However, if we make a list that has some [code]undefined[/code] values in it but request only the head of the list, which is not [code]undefined[/code], everything will go smoothly because Haskell doesn't really need to evaluate any other elements in a list if we only want to see what the first element is:


Now consider the following type:

It's your run-of-the-mill algebraic data type that was defined with the <i>data</i> keyword. It has one value constructor, which has one field whose type is [code]Bool[/code]. Let's make a function that pattern matches on a [code]CoolBool[/code] and returns the value [code]"hello"[/code] regardless of whether the [code]Bool[/code] inside the [code]CoolBool[/code] was [code]True[/code] or [code]False[/code]:

Instead of applying this function to a normal [code]CoolBool[/code],let's throw it a curveball and apply it to [code]undefined[/code]!

Yikes! An exception! Now why did this exception happen? Types defined with the <i>data</i> keyword can have multiple value constructors (even though [code]CoolBool[/code] only has one). So in order to see if the value given to our function conforms to the [code](CoolBool _)[/code] pattern, Haskell has to evaluate the value just enough to see which value constructor was used when we made the value. And when we try to evaluate an [code]undefined[/code] value, even a little, an exception is thrown.

Instead of using the <i>data</i> keyword for [code]CoolBool[/code],let's try using <i>newtype</i>:

We don't have to change our [code]helloMe[/code] function, because the pattern matching syntax is the same if you use <i>newtype</i> or <i>data</i> to define your type. Let's do the same thing here and apply [code]helloMe[/code] to an [code]undefined[/code] value:

It worked! Hmmm, why is that? Well, like we've said, when we use <i>newtype</i>, Haskell can internally represent the values of the new type in the same way as the original values. It doesn't have to add another box around them, it just has to be aware of the values being of different types. And because Haskell knows that types made with the <i>newtype</i> keyword can only have one constructor, it doesn't 
have to evaluate the value passed to the function to make sure that it conforms to the [code](CoolBool _)[/code] pattern because <i>newtype</i> types can only have one possible value constructor and one field!

This difference in behavior may seem trivial, but it's actually pretty important because it helps us realize that even though types defined with <i>data</i> and <i>newtype</i> behave similarly from the programmer's point of view because they both have value constructors and fields, they are actually two different mechanisms. Whereas <i>data</i> can be used to make your own types from scratch, <i>newtype</i> is for making a completely new type out of an existing type. Pattern matching on <i>newtype</i> values isn't like taking something out of a box (like it is with <i>data</i>), it's more about making a direct conversion from one type to another.

<h3>[code]type[/code] vs. [code]newtype[/code] vs. [code]data[/code]</h3>

At this point, you may be a bit confused about what exactly the difference between <i>type</i>, <i>data</i> and <i>newtype</i> is, so let's refresh our memory a bit.

The <em>type</em> keyword is for making type synonyms. What that means is that we just give another name to an already existing type so that the type is easier to refer to. Say we did the following:

All this does is to allow us to refer to the [code][Int][/code] type as [code]IntList[/code]. They can be used interchangeably. We don't get an [code]IntList[/code] value constructor or anything like that.
Because [code][Int][/code] and [code]IntList[/code] are only two ways to refer to the same type, it doesn't matter which name we use in our type annotations:

We use type synonyms when we want to make our type signatures more descriptive by giving types names that tell us something about their purpose in the context of the functions where they're being used. For instance, when we used an association list of type [code][(String,String)][/code] to represent a phone book, we gave it the type synonym of [code]PhoneBook[/code] so that the type signatures of our functions were easier to read.

The <em>newtype</em> keyword is for taking existing types and wrapping them in new types, mostly so that it's easier to make them instances of certain type classes. When we use <i>newtype</i> to wrap an existing type, the type that we get is separate from the original type. If we make the following <i>newtype</i>:

We can't use [code]++[/code] to put together a [code]CharList[/code] and a list of type [code][Char][/code]. We can't even use [code]++[/code] to put together two [code]CharList[/code]s, because [code]++[/code] works only on lists and the [code]CharList[/code] type isn't a list, even though it could be said that it contains one. We can, however, convert two [code]CharList[/code]s to lists, [code]++[/code] them and then convert that back to a [code]CharList[/code].

When we use record syntax in our <i>newtype</i> declarations, we get functions for converting between the new type and the original type: namely the value constructor of our <i>newtype</i> and the function for extracting the value in its field. The new type also isn't automatically made an instance of the type classes that the original type belongs to, so we have to derive or manually write them.

In practice, you can think of <i>newtype</i> declarations as <i>data</i> declarations that can only have one constructor and one field. If you catch yourself writing such a <i>data</i> declaration, consider using <i>newtype</i>.

The <em>data</em> keyword is for making your own data types and with them, you can go hog wild. They can have as many constructors and fields as you wish and can be used to implement any algebraic data type by yourself. Everything from lists and [code]Maybe[/code]-like types to trees.

If you just want your type signatures to look cleaner and be more descriptive, you probably want type synonyms. If you want to take an existing type and wrap it in a new type in order to make it an instance of a type class, chances are you're looking for a <i>newtype</i>. And if you want to make something completely new, odds are good that you're looking for the <i>data</i> keyword.
