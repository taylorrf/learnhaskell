title: Exceptions

text: All languages have procedures, functions, and pieces of code that might fail in some way. That's just a fact of life. Different languages have different ways of handling those failures. In C, we usually use some abnormal return value (like [code]-1[/code] or a null pointer) to indicate that what a function returned shouldn't be treated like a normal value. Java and C#, on the other hand, tend to use exceptions to handle failure. When an exception is thrown, the control flow jumps to some code that we've defined that does some cleanup and then maybe re-throws the exception so that some other error handling code can take care of some other stuff.

Haskell has a very good type system. Algebraic data types allow for types like [code]Maybe[/code] and [code]Either[/code] and we can use values of those types to represent results that may be there or not. In C, returning, say, [code]-1[/code] on failure is completely a matter of convention. It only has special meaning to humans. If we're not careful, we might treat these abnormal values as ordinary ones and then they can cause havoc and dismay in our code. Haskell's type system gives us some much-needed safety in that aspect. A function [code]a -&gt; Maybe b[/code] clearly indicates that it it may produce a [code]b[/code] wrapped in [code]Just[/code] or that it may return [code]Nothing[/code]. The type is different from just plain [code]a -&gt; b[/code] and if we try to use those two functions interchangeably, the compiler will complain at us.

Despite having expressive types that support failed computations, Haskell still has support for exceptions, because they make more sense in I/O contexts. A lot of things can go wrong when dealing with the outside world because it is so unreliable. For instance, when opening a file, a bunch of things can go wrong. The file might be locked, it might not be there at all or the hard disk drive or something might not be there at all. So it's good to be able to jump to some error handling part of our code when such an error occurs.
Okay, so I/O code (i.e. impure code) can throw exceptions. It makes sense. But what about pure code? Well, it can throw exceptions too. Think about the [code]div[/code] and [code]head[/code] functions. They have types of [code](Integral a) =&gt; a -&gt; a -&gt; a[/code] and [code][a] -&gt; a[/code], respectively. No [code]Maybe[/code] or [code]Either[/code] in their return type and yet they can both fail! [code]div[/code] explodes in your face if you try to divide by zero and [code]head[/code] throws a tantrum when you give it an empty list.

Pure code can throw exceptions, but it they can only be caught in the I/O part of our code (when we're inside a <i>do</i> block that goes into [code]main[/code]). That's because you don't know when (or if) anything will be evaluated in pure code, because it is lazy and doesn't have a well-defined order of execution, whereas I/O code does.
Earlier, we talked about how we should spend as little time as possible in the I/O part of our program. The logic of our program should reside mostly within our pure functions, because their results are dependant only on the parameters that the functions are called with. When dealing with pure functions, you only have to think about what a function returns, because it can't do anything else. This makes your life easier. Even though doing some logic in I/O is necessary (like opening files and the like), it should preferably be kept to a minimum. Pure functions are lazy by default, which means that we don't know when they will be evaluated and that it really shouldn't matter. However, once pure functions start throwing exceptions, it matters when they are evaluated. That's why we can only catch exceptions thrown from pure functions in the I/O part of our code. And that's bad, because we want to keep the I/O part as small as possible. However, if we don't catch them in the I/O part of our code, our program crashes. The solution? Don't mix exceptions and pure code. Take advantage of Haskell's powerful type system and use types like [code]Either[/code] and [code]Maybe[/code] to represent results that may have failed.

That's why we'll just be looking at how to use I/O exceptions for now. I/O exceptions are exceptions that are caused when something goes wrong while we are communicating with the outside world in an I/O action that's part of [code]main[/code]. For example, we can try opening a file and then it turns out that the file has been deleted or something. Take a look at this program that opens a file whose name is given to it as a command line argument and tells us how many lines the file has.


A very simple program. We perform the [code]getArgs[/code] I/O action and bind the first string in the list that it yields to [code]fileName[/code]. Then we call the contents of the file with that name [code]contents[/code]. Lastly, we apply [code]lines[/code] to those contents to get a list of lines and then we get the length of that list and give it to [code]show[/code] to get a string representation of that number. It works as expected, but what happens when we give it the name of a file that doesn't exist?


Aha, we get an error from GHC, telling us that the file does not exist. Our program crashes. What if we wanted to print out a nicer message if the file doesn't exist? One way to do that is to check if the file exists before trying to open it by using the [function]doesFileExist[/code] function from [code]System.Directory[/code].

We did [code]fileExists &lt;- doesFileExist fileName[/code] because [code]doesFileExist[/code] has a type of [code]doesFileExist :: FilePath -&gt; IO Bool[/code], which means that it returns an I/O action that has as its result a boolean value which tells us if the file exists. We can't just use [code]doesFileExist[/code] in an <i>if</i> expression directly.

Another solution here would be to use exceptions. It's perfectly acceptable to use them in this context. A file not existing is an exception that arises from I/O, so catching it in I/O is fine and dandy.
To deal with this by using exceptions, we're going to take advantage of the [function]catch[/code] function from [code]System.IO.Error[/code]. Its type is [code]catch :: IO a -&gt; (IOError -&gt; IO a) -&gt; IO a[/code]. It takes two parameters. The first one is an I/O action. For instance, it could be an I/O action that tries to open a file. The second one is the so-called handler. If the first I/O action passed to [code]catch[/code] throws an I/O exception, that exception gets passed to the handler, which then decides what to do. So the final result is an I/O action that will either act the same as the first parameter or it will do what the handler tells it if the first I/O action throws an exception.

If you're familiar with <i>try-catch</i> blocks in languages like Java or Python, the [code]catch[/code] function is similar to them. The first parameter is the thing to try, kind of like the stuff in the <i>try</i> block in other, imperative languages. The second parameter is the handler that takes an exception, just like most <i>catch</i> blocks take exceptions that you can then examine to see what happened. The handler is invoked if an exception is thrown.
The handler takes a value of type [code]IOError[/code], which is a value that signifies that an I/O exception occurred. It also carries information regarding the type of the exception that was thrown. How this type is implemented depends on the implementation of the language itself, which means that we can't inspect values of the type [code]IOError[/code] by pattern matching against them, just like we can't pattern match against values of type [code]IO <i>something</i>[/code]. We can use a bunch of useful predicates to find out stuff about values of type [code]IOError[/code] as we'll learn in a second.

So let's put our new friend [code]catch[/code] to use!



First of all, you'll see that put backticks around it so that we can use it as an infix function, because it takes two parameters. Using it as an infix function makes it more readable. So [code]toTry `catch` handler[/code] is the same as [code]catch toTry handler[/code], which fits well with its type. [code]toTry[/code] is the I/O action that we try to carry out and [code]handler[/code] is the function that takes an [code]IOError[/code] and returns an action to be carried out in case of an exception.

Let's give this a go:


In the handler, we didn't check to see what kind of [code]IOError[/code] we got. We just say [code]"Whoops, had some trouble!"[/code] for any kind of error. Just catching all types of exceptions in one handler is bad practice in Haskell just like it is in most other languages. What if some other exception happens that we don't want to catch, like us interrupting the program or something? That's why we're going to do the same thing that's usually done in other languages as well: we'll check to see what kind of exception we got. If it's the kind of exception we're waiting to catch, we do our stuff. If it's not, we throw that exception back into the wild. Let's modify our program to catch only the exceptions caused by a file not existing.


Everything stays the same except the handler, which we modified to only catch a certain group of I/O exceptions. Here we used two new functions from [code]System.IO.Error[/code] â€” [function]isDoesNotExistError[/code] and [function]ioError[/code]. [code]isDoesNotExistError[/code] is a predicate over [code]IOError[/code]s, which means that it's a function that takes an [code]IOError[/code] and returns a [code]True[/code] or [code]False[/code], meaning it has a type of [code]isDoesNotExistError :: IOError -&gt; Bool[/code]. We use it on the exception that gets passed to our handler to see if it's an error caused by a file not existing. We use <a href="syntax-in-functions#guards-guards">guard</a> syntax here, but we could have also used an <i>if else</i>. If it's not caused by a file not existing, we re-throw the exception that was passed by the handler with the [code]ioError[/code] function. It has a type of [code]ioError :: IOException -&gt; IO a[/code], so it takes an [code]IOError[/code] and produces an I/O action that will throw it. The I/O action has a type of [code]IO a[/code], because it never actually yields a result, so it can act as [code]IO <i>anything</i>[/code].

So the exception thrown in the [code]toTry[/code] I/O action that we glued together with a <i>do</i> block isn't caused by a file existing, [code]toTry `catch` handler[/code] will catch that and then re-throw it. Pretty cool, huh?
There are several predicates that act on [code]IOError[/code] and if a guard doesn't evaluate to [code]True[/code], evaluation falls through to the next guard. The predicates that act on [code]IOError[/code] are:


Most of these are pretty self-explanatory. [code]isUserError[/code] evaluates to [code]True[/code] when we use the function [function]userError[/code] to make the exception, which is used for making exceptions from our code and equipping them with a string. For instance, you can do [code]ioError $ userError "remote computer unplugged!"[/code], although It's prefered you use types like [code]Either[/code] and [code]Maybe[/code] to express possible failure instead of throwing exceptions yourself with [code]userError[/code].

So you could have a handler that looks something like this:


Where [code]notifyCops[/code] and [code]freeSomeSpace[/code] are some I/O actions that you define. Be sure to re-throw exceptions if they don't match any of your criteria, otherwise you're causing your program to fail silently in some cases where it shouldn't.
[code]System.IO.Error[/code] also exports functions that enable us to ask our exceptions for some attributes, like what the handle of the file that caused the error is, or what the filename is. These start with [code]ioe[/code] and you can see a <a href="http://www.haskell.org/ghc/docs/6.10.1/html/libraries/base/System-IO-Error.html#3">full list of them</a> in the documentation. Say we want to print the filename that caused our error. We can't print the [code]fileName[/code] that we got from [code]getArgs[/code], because only the [code]IOError[/code] is passed to the handler and the handler doesn't know about anything else. A function depends only on the parameters it was called with. That's why we can use the [function]ioeGetFileName[/code] function, which has a type of [code]ioeGetFileName :: IOError -&gt; Maybe FilePath[/code]. It takes an [code]IOError[/code] as a parameter and maybe returns a [code]FilePath[/code] (which is just a type synonym for [code]String[/code], remember, so it's kind of the same thing). Basically, what it does is it extracts the file path from the [code]IOError[/code], if it can. Let's modify our program to print out the file path that's responsible for the exception occurring.

In the guard where [code]isDoesNotExistError[/code] is [code]True[/code], we used a <i>case</i> expression to call [code]ioeGetFileName[/code] with [code]e[/code] and then pattern match against the [code]Maybe[/code] value that it returned. Using <i>case</i> expressions is commonly used when you want to pattern match against something without bringing in a new function.

You don't have to use one handler to [code]catch[/code] exceptions in your whole I/O part. You can just cover certain parts of your I/O code with [code]catch[/code] or you can cover several of them with [code]catch[/code] and use different handlers for them, like so:


Here, [code]toTry[/code] uses [code]handler1[/code] as the handler and [code]thenTryThis[/code] uses [code]handler2[/code]. [code]launchRockets[/code] isn't a parameter to [code]catch[/code], so whichever exceptions it might throw will likely crash our program, unless [code]launchRockets[/code] uses [code]catch[/code] internally to handle its own exceptions. Of course [code]toTry[/code], [code]thenTryThis[/code] and [code]launchRockets[/code] are I/O actions that have been glued together using <i>do</i> syntax and hypothetically defined somewhere else. This is kind of similar to <i>try-catch</i> blocks of other languages, where you can surround your whole program in a single <i>try-catch</i> or you can use a more fine-grained approach and use different ones in different parts of your code to control what kind of error handling happens where.

Now you know how to deal with I/O exceptions! Throwing exceptions from pure code and dealing with them hasn't been covered here, mainly because, like we said, Haskell offers much better ways to indicate errors than reverting to I/O to catch them. Even when glueing together I/O actions that might fail, I prefer to have their type be something like [code]IO (Either a b)[/code], meaning that they're normal I/O actions but the result that they yield when performed is of type [code]Either a b[/code], meaning it's either [code]Left a[/code] or [code]Right b[/code].