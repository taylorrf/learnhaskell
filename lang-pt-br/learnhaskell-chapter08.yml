chapter: Criando seus próprios tipos e typeclasses

text: Nos capítulos anteriores, vimos alguns tipos e typeclasses de Haskell. Neste capítulo, aprenderemos como criar nossos próprios e colocá-los para funcionar!


title: Introdução a tipos de dados algébricos

text: Até agora, vimos vários tipos de dados. [code]Bool[/code], [code]Int[/code], [code]Char[/code], [code]Maybe[/code], etc. Mas como criar nosso próprio? Bom, um jeito é usar a palavra-chave <em>data</em> para definir um tipo. Vamos ver como o tipo [code]Bool[/code] é definido na biblioteca padrão.



[code]data[/code] significa que estamos definindo um novo tipo de dados. A parte anterior a [code]=[/code] diz o tipo, que é [code]Bool[/code]. A de depois são <em>value constructors</em> (construtores de valores). Eles especificam os diferentes valores que o tipo pode assumir. O [code]|[/code] pode ser lido como <i>ou</i>. Então você pode ler tudo como: o tipo [code]Bool[/code] pode ter valores [code]True[/code] ou [code]False[/code]. Tipos ou construtores de valor devem começar com letras maiúsculas.

Da mesma maneira, podemos imaginar o tipo [code]Int[/code] como sendo definido como:



Os primeiro e último construtores são os valores menores e maiores possíveis de [code]Int[/code]. Não é definido exatamente assim, as reticências estão aí apenas com propósitos ilustrativos já que omitimos uma grande quantidade de números.	

Por agora, vamos pensar como podemos representar uma forma geométrica em Haskell. Um jeito é usar tuplas. Um círculo pode ser como [code](43.1, 55.0, 10.4)[/code] onde o primeiro e o segundo campos são as coordenadas do centro do círculo e o terceiro é o raio. Parace bom, mas também serve para representar qualquer vetor 3D ou algo do gênero. A melhor solução seria dizer qual é a forma, se um círculo ou retângulo. Aí:




E agora? Gostei, ao menos. O value constructor [code]Circle[/code] tem três campos float. Então quando escrevemos um value constructor, nós podemos adicionar tipos que o nosso novo tipo conterá. Aqui, os dois primeiros campos são as coordenadas do centro, o terceiro o raio. O value constructor [code]Rectangle[/code] tem quatro campos float. Os dois primeiros são as coordenadas do ponto superior esquerdo e os outros dois do inferior direito.

Mas quando falo campos, quero dizer parâmetros. Value constructors basicamente são funções que retornam um valor em um tipo de dados. Vejamos como estão declarados os tipos desses dois construtores.


Legal, então value constructors são funções como todo o resto. Quem imaginaria? Vamos fazer uma função que recebe uma forma geométrica e que retorna a sua superfície.



A primeira coisa digna de nota é a declaração de tipo. Diz que uma função recebe uma forma geométrica e retorna um float. Nós não poderíamos escrever o tipo como [code]Circle -&gt; Float[/code] porque [code]Circle[/code] não é um tipo, [code]Shape[/code] é. Seria como escrever uma função com [code]True -&gt; Int[/code]. A próxima coisa é que podemos usar pattern match em construtores. Nós já fizemos isso (várias vezes por sinal) ao testar patterns por [code][][/code] ou [code]False[/code] ou [code]5[/code], com a diferença que não haviam tantos campos. Nós apenas escrevemos o construtor e associamos seus campos a nomes. Como estamos interessados no raio, não nos é importante os dois primeiros campos, que nos dizem onde o círculo está.




Ei, funciona! Mas se tentarmos escrever [code]Circle 10 20 5[/code] no prompt, teremos um erro. Isso é devido ao Haskell não saber mostrar nosso tipo de dado como string (ainda). Lembre-se, quando tentamos mostrar um valor na tela, Haskell primeiro executa a função [code]show[/code] para conseguir a versão em string do nosso valor e mostra no terminal. Para fazer o nosso tipo [code]Shape[/code] parte da typeclass [code]Show[/code] nós o modificamos desse modo:




Não vamos ir muito a fundo com o uso do deriving por enquanto. Digamos que adicionemos [code]deriving (Show)[/code] no fim da declaração de <i>data</i>, Haskell automaticamente faz esse tipo parte da typeclass [code]Show[/code]. Logo, podemos fazer assim:




Value constructors são funções, então podemos mapear e aplicá-los a algo e tudo mais. Se queremos ter uma lista de círculos com diferentes raios, podemos fazer assim.



Nosso tipo de dados está bom, mas poderia estar melhor. Vamos criar um tipo de dados intermediário que define um ponto em um espaço bidimensional e então deixar nossas formas geométricas mais fáceis de se entender.



Perceba que quando definimos um ponto, usamos o mesmo nome para o tipo de dados e o value constructor. Isso não tem nenhum funcionamento especial, mas é um padrão informal para quando o value constructor só pode assumir um valor. Agora que o [code]Circle[/code] tem dois campos, um deles do tipo [code]Point[/code] e outro [code]Float[/code]. Isso torna as coisas mais claras. E o mesmo para o retângulo. Só temos que modificar a função [code]surface[/code] para passar a refletir as mudanças.




A única coisa que tivemos que mudar foram os patterns. A parte que se refere ao círculo permaanece igual. No pattern do retângulo, nós usamos pattern matching aninhadamente para conseguir as medidas las linhas da figura. Se quiséssemos os próprios pontos por alguma razão, poderíamos ter usado as-patterns.




Que tal uma função que move uma figura? Recebe uma figura, o tanto a se mover no eixo x e no eixo y para retornas uma nova figura de mesmas dimensões, localizada em outra posição.




Bastante simples. Nós somamos a quantidade de movimento à cada um dos pontos da figura.



Se não quisermos mexer diretamente com pontos, podemos criar funções auxiliares para criar figuras do tamanho determinado no ponto zero e a partir daí movê-las.

Você pode, é claro, exportar os tipos de dados em seus módulos. Para isso, apenas escreva o tipo junto das funções que está exportando e, entre parênteses, especifique os tipos dos construtores que devem ser exportados, separados por vírgulas. Se quiser exportar todos os construtores de valores de um tipo, apenas escreva [code]..[/code].

Se queremos exportar as funções e tipos que definimos no módulo, podemos usar algo como isso:

Com o [code]Shape(..)[/code], exportamos todos os construtores de valores de [code]Shape[/code], o que significa que quem importar nosso módulo poderá criar formas usando os construtores de valores [code]Rectangle[/code] e [code]Circle[/code]. É o mesmo que escrever [code]Shape (Rectangle, Circle)[/code].

Poderíamos ainda optar por exportar nenhum dos construtores de valores de [code]Shape[/code], escrevendo [code]Shape[/code] no código de exportação. Desse modo, quem importasse o nosso módulo poderia criar formas usando as funções auxiliares [code]baseCircle[/code] e [code]baseRect[/code]. [code]Data.Map[/code] funciona assim. Você não pode criar um mapa usando [code]Map.Map [(1,2),(3,4)][/code] porque não exporta o construtor de valor. De qualquer maneira, pode usando funções auxiliares como [code]Map.fromList[/code]. Lembre-se, construtores de valores nada mais são do que funções que recebem campos como parâmetros e retornam valores do mesmo tipo (como [code]Shape[/code]) e seu retorno. Então quando decidimos não exportá-los, proibimos que alguém importando nosso módulo os use. Mas se outras funções não retornam um tipo, podemos usá-las para criar valores dos tipos de dados costumizados.

Não exportar os construtores de valores de tipos de dados os fazem mais abstratos, de modo que escondemos a sua implementação. Vale ressaltar que quem importar nosso módulo não pode usar pattern match em construtores de valores.
