title: Pensando recursivamente

text: Fizemos um bom tanto de recursão até agora e, como você provavelmente notou, há um padrão aqui. Normalmente você define uma condição limite e então você define uma função que faz alguma coisa entre algum elemento e a função aplicada ao resto. Não importa se é uma lista, uma árvore ou qualquer outra estrutura de dados. Uma soma é o primeiro elemento de uma lista mais a soma do resto da lista. Um produto de uma lista é o primeiro elemento da lista vezes o produto do resto da lista. O tamanho de uma lista é um mais o tamanho do resto da lista. Ekcetera, ekcetera ...

É claro, há também as condições limite. Normalmente o caso limite é algum cenário onde uma aplicação recursiva não faz sentido. Quando tratando de listas, a condição limite é na maioria da vezes uma lista vazia. Se você está tratando de árvores, o caso limite é normalmente um nodo que não tem criança alguma.

É similar quando você está tratando com números recursivamente. Normalmente tem a ver com algum número e a função aplicada a aquele número modificada. Nós fizemos anteriormente a função fatorial e é o produto de um número e o fatorial daquele número menos um. Tal aplicação recursiva não faz sentido com zero, porque fatoriais estão definidos somente para inteiros positivos. Frequentemente os valores das condições limite acabam sendo uma identidade. A identidade da multiplicação é 1 porque se você multiplicar alguma coisa por 1, você recebe de volta aquela coisa. Também quando fazendo somas de listas, nós definimos a soma de uma lista vazia como 0 e 0 é a identidade da adição. No quicksort, o caso limite é a lista vazia e a identidade é também a lista vazia, porque se você adicionar uma lista vazia a uma lista, você apenas recebe de volta a lista original.

Então você quando tentar pensar de uma forma recursiva para resolver um problema, tente pensar em quando a solução recursiva não se aplica e ver se você pode usar isso como uma condição limite, pense sobre identidades e pense sobre se você vai dividir em partes os parâmetros da função (por exemplo, listas são normalmente divididas em cabeça e calda através do reconhecimento de padrões) e em que parte você usará uma chamada recursiva.
